<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ TargetRTS: RTObject_class Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C++ TargetRTS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_r_t_object__class-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">RTObject_class Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A type descriptor providing information about a type.  
 <a href="struct_r_t_object__class.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_r_t_object__class_8h_source.html">RTObject_class.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTObject_class:</div>
<div class="dyncontent">
 <div class="center">
  <img src="struct_r_t_object__class.png" usemap="#RTObject_5Fclass_map" alt=""/>
  <map id="RTObject_5Fclass_map" name="RTObject_5Fclass_map">
<area href="struct_r_t_array__class.html" alt="RTArray_class" shape="rect" coords="0,56,100,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a594936f7c7992d3efa7ff24b8c2250fa"><td class="memItemLeft" align="right" valign="top"><a id="a594936f7c7992d3efa7ff24b8c2250fa" name="a594936f7c7992d3efa7ff24b8c2250fa"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>DestroyOption</b> { <b>DestroyOnly</b>
, <b>DestroyAndDeallocate</b>
 }</td></tr>
<tr class="separator:a594936f7c7992d3efa7ff24b8c2250fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6db504dac422677aa07d0995f9949f68"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a6db504dac422677aa07d0995f9949f68">super</a> (void) const</td></tr>
<tr class="memdesc:a6db504dac422677aa07d0995f9949f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the descriptor for the super type, i.e.  <br /></td></tr>
<tr class="separator:a6db504dac422677aa07d0995f9949f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c4ce75f1db881601aad4102db311d5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a80c4ce75f1db881601aad4102db311d5">name</a> (void) const</td></tr>
<tr class="memdesc:a80c4ce75f1db881601aad4102db311d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the described type.  <br /></td></tr>
<tr class="separator:a80c4ce75f1db881601aad4102db311d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6122064de4a3cacf3100b9b0b9eac1d"><td class="memItemLeft" align="right" valign="top">RTVersionId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#ab6122064de4a3cacf3100b9b0b9eac1d">version</a> (void) const</td></tr>
<tr class="memdesc:ab6122064de4a3cacf3100b9b0b9eac1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the version of the described type.  <br /></td></tr>
<tr class="separator:ab6122064de4a3cacf3100b9b0b9eac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447a3ee64856b04887dcd61e793ea4cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a447a3ee64856b04887dcd61e793ea4cb">isKindOf</a> (const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *other) const</td></tr>
<tr class="memdesc:a447a3ee64856b04887dcd61e793ea4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the described type is the same, or a subtype of, another type.  <br /></td></tr>
<tr class="separator:a447a3ee64856b04887dcd61e793ea4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab279a52b5021c3448ede84ad6a361fa6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#ab279a52b5021c3448ede84ad6a361fa6">allocate</a> (void) const</td></tr>
<tr class="memdesc:ab279a52b5021c3448ede84ad6a361fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate new memory for holding an instance of the described type.  <br /></td></tr>
<tr class="separator:ab279a52b5021c3448ede84ad6a361fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8031d7bef7c462af4b3c401243909ff0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a8031d7bef7c462af4b3c401243909ff0">init</a> (void *data) const</td></tr>
<tr class="memdesc:a8031d7bef7c462af4b3c401243909ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an instance of the described type.  <br /></td></tr>
<tr class="separator:a8031d7bef7c462af4b3c401243909ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39996e993557019ae4cfd4361bd8ce71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a39996e993557019ae4cfd4361bd8ce71">copy</a> (void *to, const void *from) const</td></tr>
<tr class="memdesc:a39996e993557019ae4cfd4361bd8ce71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of an instance of the described type.  <br /></td></tr>
<tr class="separator:a39996e993557019ae4cfd4361bd8ce71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457331800e26444b0a8021c65f456dc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a457331800e26444b0a8021c65f456dc5">move</a> (void *to, void *from) const</td></tr>
<tr class="memdesc:a457331800e26444b0a8021c65f456dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an instance of the described type.  <br /></td></tr>
<tr class="separator:a457331800e26444b0a8021c65f456dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad015dfa7ffc676993900e7176a8a9f64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#ad015dfa7ffc676993900e7176a8a9f64">decode</a> (void *data, <a class="el" href="class_r_t_decoding.html">RTDecoding</a> *decoder) const</td></tr>
<tr class="memdesc:ad015dfa7ffc676993900e7176a8a9f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode an external representation (e.g.  <br /></td></tr>
<tr class="separator:ad015dfa7ffc676993900e7176a8a9f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123c62181ab608814ddf14e1e769652b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a123c62181ab608814ddf14e1e769652b">encode</a> (const void *data, <a class="el" href="class_r_t_encoding.html">RTEncoding</a> *encoder) const</td></tr>
<tr class="memdesc:a123c62181ab608814ddf14e1e769652b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an instance of the described type into an external representation (e.g.  <br /></td></tr>
<tr class="separator:a123c62181ab608814ddf14e1e769652b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31361e1557e264e1e987242fb34998b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a31361e1557e264e1e987242fb34998b2">destroy</a> (void *inst, DestroyOption opt) const</td></tr>
<tr class="memdesc:a31361e1557e264e1e987242fb34998b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an instance of the described type.  <br /></td></tr>
<tr class="separator:a31361e1557e264e1e987242fb34998b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450363e1f800cb3f2abaf918aca9ec68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a450363e1f800cb3f2abaf918aca9ec68">install</a> (bool warnForDuplicates=true) const</td></tr>
<tr class="memdesc:a450363e1f800cb3f2abaf918aca9ec68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the type descriptor so it can be looked up quickly using the name of the described type as the key.  <br /></td></tr>
<tr class="separator:a450363e1f800cb3f2abaf918aca9ec68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae172a3c9d360050394069d56c7fed29e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#ae172a3c9d360050394069d56c7fed29e">lookup</a> (const char *className)</td></tr>
<tr class="memdesc:ae172a3c9d360050394069d56c7fed29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a type descriptor by the name of the type it describes.  <br /></td></tr>
<tr class="separator:ae172a3c9d360050394069d56c7fed29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a7107b6759a983fab2734c9724c4f4"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:ae1a7107b6759a983fab2734c9724c4f4"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#ae1a7107b6759a983fab2734c9724c4f4">fromType</a> ()</td></tr>
<tr class="memdesc:ae1a7107b6759a983fab2734c9724c4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a type descriptor from a type TYPE at compile-time.  <br /></td></tr>
<tr class="separator:ae1a7107b6759a983fab2734c9724c4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memItemLeft" align="right" valign="top"><a id="a976bffccca8cf70ca6a6cfd24b9fdfe8" name="a976bffccca8cf70ca6a6cfd24b9fdfe8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fromType</b> ()</td></tr>
<tr class="separator:a976bffccca8cf70ca6a6cfd24b9fdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4da12ad183c04e16dda9526ef71ea7c3"><td class="memItemLeft" align="right" valign="top"><a id="a4da12ad183c04e16dda9526ef71ea7c3" name="a4da12ad183c04e16dda9526ef71ea7c3"></a>
const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_super</b></td></tr>
<tr class="memdesc:a4da12ad183c04e16dda9526ef71ea7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The super type from which the type inherits. <br /></td></tr>
<tr class="separator:a4da12ad183c04e16dda9526ef71ea7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8e9e3da1667d697709d67c48503989"><td class="memItemLeft" align="right" valign="top"><a id="ada8e9e3da1667d697709d67c48503989" name="ada8e9e3da1667d697709d67c48503989"></a>
RTSuperAccessFunction&#160;</td><td class="memItemRight" valign="bottom"><b>_super_accessor</b></td></tr>
<tr class="memdesc:ada8e9e3da1667d697709d67c48503989"><td class="mdescLeft">&#160;</td><td class="mdescRight">The super object accessor function for this type. <br /></td></tr>
<tr class="separator:ada8e9e3da1667d697709d67c48503989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40188900d2badd69841da178def36f1"><td class="memItemLeft" align="right" valign="top"><a id="af40188900d2badd69841da178def36f1" name="af40188900d2badd69841da178def36f1"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>_name</b></td></tr>
<tr class="memdesc:af40188900d2badd69841da178def36f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the type. <br /></td></tr>
<tr class="separator:af40188900d2badd69841da178def36f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab298b2999fe5e7bb68a1299bb085826c"><td class="memItemLeft" align="right" valign="top"><a id="ab298b2999fe5e7bb68a1299bb085826c" name="ab298b2999fe5e7bb68a1299bb085826c"></a>
RTVersionId&#160;</td><td class="memItemRight" valign="bottom"><b>_version</b></td></tr>
<tr class="memdesc:ab298b2999fe5e7bb68a1299bb085826c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The version id of the type. <br /></td></tr>
<tr class="separator:ab298b2999fe5e7bb68a1299bb085826c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb20514ce0030eb9af054cbb26ddb08d"><td class="memItemLeft" align="right" valign="top"><a id="abb20514ce0030eb9af054cbb26ddb08d" name="abb20514ce0030eb9af054cbb26ddb08d"></a>
RTFieldOffset&#160;</td><td class="memItemRight" valign="bottom"><b>_size</b></td></tr>
<tr class="memdesc:abb20514ce0030eb9af054cbb26ddb08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size (in bytes) of the type. <br /></td></tr>
<tr class="separator:abb20514ce0030eb9af054cbb26ddb08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eb31f506e578e21120ee8d01fcef73"><td class="memItemLeft" align="right" valign="top">RTInitFunction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a10eb31f506e578e21120ee8d01fcef73">_init_func</a></td></tr>
<tr class="memdesc:a10eb31f506e578e21120ee8d01fcef73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The init function of the type, i.e.  <br /></td></tr>
<tr class="separator:a10eb31f506e578e21120ee8d01fcef73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a1046e1ee77fd38e5f22728db6bc06"><td class="memItemLeft" align="right" valign="top">RTCopyFunction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#ac0a1046e1ee77fd38e5f22728db6bc06">_copy_func</a></td></tr>
<tr class="memdesc:ac0a1046e1ee77fd38e5f22728db6bc06"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy function of the type, i.e.  <br /></td></tr>
<tr class="separator:ac0a1046e1ee77fd38e5f22728db6bc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14df7d874ccc14c01cbadbb1af151161"><td class="memItemLeft" align="right" valign="top">RTMoveFunction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a14df7d874ccc14c01cbadbb1af151161">_move_func</a></td></tr>
<tr class="memdesc:a14df7d874ccc14c01cbadbb1af151161"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move function of the type, i.e.  <br /></td></tr>
<tr class="separator:a14df7d874ccc14c01cbadbb1af151161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab861b4c107068ef4679b8baba6beb81"><td class="memItemLeft" align="right" valign="top"><a id="aab861b4c107068ef4679b8baba6beb81" name="aab861b4c107068ef4679b8baba6beb81"></a>
RTDecodeFunction&#160;</td><td class="memItemRight" valign="bottom"><b>_decode_func</b></td></tr>
<tr class="memdesc:aab861b4c107068ef4679b8baba6beb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The decode function of the type. <br /></td></tr>
<tr class="separator:aab861b4c107068ef4679b8baba6beb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cd6389f97d4aa0428be4bbb83c5fb0"><td class="memItemLeft" align="right" valign="top"><a id="a03cd6389f97d4aa0428be4bbb83c5fb0" name="a03cd6389f97d4aa0428be4bbb83c5fb0"></a>
RTEncodeFunction&#160;</td><td class="memItemRight" valign="bottom"><b>_encode_func</b></td></tr>
<tr class="memdesc:a03cd6389f97d4aa0428be4bbb83c5fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The encode function of the type. <br /></td></tr>
<tr class="separator:a03cd6389f97d4aa0428be4bbb83c5fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a4448dcbda20338dae4afbb8d8b951"><td class="memItemLeft" align="right" valign="top">RTDestroyFunction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a12a4448dcbda20338dae4afbb8d8b951">_destroy_func</a></td></tr>
<tr class="memdesc:a12a4448dcbda20338dae4afbb8d8b951"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destroy function of the type, i.e.  <br /></td></tr>
<tr class="separator:a12a4448dcbda20338dae4afbb8d8b951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24282ceff1d24cf7de29ee02d6dec198"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#a24282ceff1d24cf7de29ee02d6dec198">_num_fields</a></td></tr>
<tr class="memdesc:a24282ceff1d24cf7de29ee02d6dec198"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable is used for structured and array-like types to specify the number of fields or elements that are contained in the type.  <br /></td></tr>
<tr class="separator:a24282ceff1d24cf7de29ee02d6dec198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c2d997bc69676067568d48187abb64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_field_descriptor.html">RTFieldDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_t_object__class.html#ac8c2d997bc69676067568d48187abb64">_fields</a></td></tr>
<tr class="memdesc:ac8c2d997bc69676067568d48187abb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable is used for structured and array-like types to specify the type of fields or elements that are contained in the type.  <br /></td></tr>
<tr class="separator:ac8c2d997bc69676067568d48187abb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A type descriptor providing information about a type. </p>
<p>For most types defined in the model a static variable of this struct will be automatically generated. For more complex types, or to have a type descriptor with a non-default behavior, you can write you own custom type descriptor. Capsule types have their own type descriptor struct; see <a class="el" href="struct_r_t_actor__class.html">RTActor_class</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab279a52b5021c3448ede84ad6a361fa6" name="ab279a52b5021c3448ede84ad6a361fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab279a52b5021c3448ede84ad6a361fa6">&#9670;&#160;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * RTObject_class::allocate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate new memory for holding an instance of the described type. </p>
<dl class="section return"><dt>Returns</dt><dd>Allocated memory big enough to hold an instance of the described type. </dd></dl>

</div>
</div>
<a id="a39996e993557019ae4cfd4361bd8ce71" name="a39996e993557019ae4cfd4361bd8ce71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39996e993557019ae4cfd4361bd8ce71">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTObject_class::copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a copy of an instance of the described type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>The target object into which the data will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The source object that will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad015dfa7ffc676993900e7176a8a9f64" name="ad015dfa7ffc676993900e7176a8a9f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad015dfa7ffc676993900e7176a8a9f64">&#9670;&#160;</a></span>decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTObject_class::decode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_decoding.html">RTDecoding</a> *&#160;</td>
          <td class="paramname"><em>decoder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode an external representation (e.g. </p>
<p>a string representation) and populate an instance of the described type accordingly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The target object into which the decoded data will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decoder</td><td>The decoder implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if decoding was successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a31361e1557e264e1e987242fb34998b2" name="a31361e1557e264e1e987242fb34998b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31361e1557e264e1e987242fb34998b2">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTObject_class::destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DestroyOption&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an instance of the described type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inst</td><td>An instance of the described type to destroy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>Specifies whether the memory for the data object should be deallocated as part of destruction or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a123c62181ab608814ddf14e1e769652b" name="a123c62181ab608814ddf14e1e769652b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123c62181ab608814ddf14e1e769652b">&#9670;&#160;</a></span>encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTObject_class::encode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_encoding.html">RTEncoding</a> *&#160;</td>
          <td class="paramname"><em>encoder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode an instance of the described type into an external representation (e.g. </p>
<p>a string representation). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The instance of the described type to encode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoder</td><td>The encoder implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if encoding was successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ae1a7107b6759a983fab2734c9724c4f4" name="ae1a7107b6759a983fab2734c9724c4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a7107b6759a983fab2734c9724c4f4">&#9670;&#160;</a></span>fromType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> * RTObject_class::fromType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a type descriptor from a type TYPE at compile-time. </p>
<p>This template function is specialized for all built-in and RT types. If you have manually implemented a type descriptor for a type you must also manually specialize this template if you need to lookup that type descriptor at compile-time. </p><dl class="section return"><dt>Returns</dt><dd>The type descriptor for the type, or null if the TYPE doesn't have a type descriptor defined. </dd></dl>

</div>
</div>
<a id="a8031d7bef7c462af4b3c401243909ff0" name="a8031d7bef7c462af4b3c401243909ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8031d7bef7c462af4b3c401243909ff0">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTObject_class::init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an instance of the described type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object for an instance of the described type, typically allocated by a call to <a class="el" href="struct_r_t_object__class.html#ab279a52b5021c3448ede84ad6a361fa6" title="Allocate new memory for holding an instance of the described type.">allocate()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a450363e1f800cb3f2abaf918aca9ec68" name="a450363e1f800cb3f2abaf918aca9ec68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450363e1f800cb3f2abaf918aca9ec68">&#9670;&#160;</a></span>install()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTObject_class::install </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warnForDuplicates</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the type descriptor so it can be looked up quickly using the name of the described type as the key. </p>
<p>See <a class="el" href="struct_r_t_object__class.html#ae172a3c9d360050394069d56c7fed29e" title="Lookup a type descriptor by the name of the type it describes.">lookup()</a> for how to perform the lookup. All generated type descriptors will be automatically installed, so normally this function should not be called from user code. See RTTypeInstaller for more information. However, if you have manually written types for which you want to register a type descriptor, you need to call this function to install it in the registry. The name of the installed type is used as the key in the registry. If a type with that name is already registered (the same type or a different one) this function does nothing, but prints a warning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">warnForDuplicates</td><td>Set to false to avoid printing a warning if trying to register a type descriptor with a name that is already used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a447a3ee64856b04887dcd61e793ea4cb" name="a447a3ee64856b04887dcd61e793ea4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447a3ee64856b04887dcd61e793ea4cb">&#9670;&#160;</a></span>isKindOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTObject_class::isKindOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the described type is the same, or a subtype of, another type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Type descriptor for the other type to check the described type against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if yes, 0 if no. </dd></dl>

</div>
</div>
<a id="ae172a3c9d360050394069d56c7fed29e" name="ae172a3c9d360050394069d56c7fed29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae172a3c9d360050394069d56c7fed29e">&#9670;&#160;</a></span>lookup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> * RTObject_class::lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>className</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup a type descriptor by the name of the type it describes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">className</td><td>Name of the type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type descriptor for the type, or null if the TYPE doesn't have a type descriptor defined. </dd></dl>

</div>
</div>
<a id="a457331800e26444b0a8021c65f456dc5" name="a457331800e26444b0a8021c65f456dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457331800e26444b0a8021c65f456dc5">&#9670;&#160;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTObject_class::move </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an instance of the described type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>The target object into which the data will be moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The source object that will be moved from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80c4ce75f1db881601aad4102db311d5" name="a80c4ce75f1db881601aad4102db311d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c4ce75f1db881601aad4102db311d5">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * RTObject_class::name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the described type. </p>
<dl class="section return"><dt>Returns</dt><dd>Type name </dd></dl>

</div>
</div>
<a id="a6db504dac422677aa07d0995f9949f68" name="a6db504dac422677aa07d0995f9949f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db504dac422677aa07d0995f9949f68">&#9670;&#160;</a></span>super()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> * RTObject_class::super </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the descriptor for the super type, i.e. </p>
<p>the type from which the described type inherits. </p><dl class="section return"><dt>Returns</dt><dd>Type descriptor for the super type, or null if there is no super type. </dd></dl>

</div>
</div>
<a id="ab6122064de4a3cacf3100b9b0b9eac1d" name="ab6122064de4a3cacf3100b9b0b9eac1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6122064de4a3cacf3100b9b0b9eac1d">&#9670;&#160;</a></span>version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTVersionId RTObject_class::version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the version of the described type. </p>
<dl class="section return"><dt>Returns</dt><dd>Type version (usually 0 for the first version, and then incremented by one each time the type changes). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac0a1046e1ee77fd38e5f22728db6bc06" name="ac0a1046e1ee77fd38e5f22728db6bc06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a1046e1ee77fd38e5f22728db6bc06">&#9670;&#160;</a></span>_copy_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTCopyFunction RTObject_class::_copy_func</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The copy function of the type, i.e. </p>
<p>its copy constructor </p>

</div>
</div>
<a id="a12a4448dcbda20338dae4afbb8d8b951" name="a12a4448dcbda20338dae4afbb8d8b951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a4448dcbda20338dae4afbb8d8b951">&#9670;&#160;</a></span>_destroy_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTDestroyFunction RTObject_class::_destroy_func</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The destroy function of the type, i.e. </p>
<p>its destructor </p>

</div>
</div>
<a id="ac8c2d997bc69676067568d48187abb64" name="ac8c2d997bc69676067568d48187abb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c2d997bc69676067568d48187abb64">&#9670;&#160;</a></span>_fields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_r_t_field_descriptor.html">RTFieldDescriptor</a>* RTObject_class::_fields</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable is used for structured and array-like types to specify the type of fields or elements that are contained in the type. </p>
<p>For other kinds of types this variable is not relevant. The variable is an array of descriptor objects, each of which describes one field or element of the type. </p>

</div>
</div>
<a id="a10eb31f506e578e21120ee8d01fcef73" name="a10eb31f506e578e21120ee8d01fcef73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10eb31f506e578e21120ee8d01fcef73">&#9670;&#160;</a></span>_init_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTInitFunction RTObject_class::_init_func</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The init function of the type, i.e. </p>
<p>its default constructor </p>

</div>
</div>
<a id="a14df7d874ccc14c01cbadbb1af151161" name="a14df7d874ccc14c01cbadbb1af151161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14df7d874ccc14c01cbadbb1af151161">&#9670;&#160;</a></span>_move_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTMoveFunction RTObject_class::_move_func</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The move function of the type, i.e. </p>
<p>its move constructor </p>

</div>
</div>
<a id="a24282ceff1d24cf7de29ee02d6dec198" name="a24282ceff1d24cf7de29ee02d6dec198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24282ceff1d24cf7de29ee02d6dec198">&#9670;&#160;</a></span>_num_fields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTObject_class::_num_fields</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable is used for structured and array-like types to specify the number of fields or elements that are contained in the type. </p>
<p>For other kinds of types this variable is not relevant. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="_r_t_object__class_8h_source.html">RTObject_class.h</a></li>
<li>RTObject_class.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
