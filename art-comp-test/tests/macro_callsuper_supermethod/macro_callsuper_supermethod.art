/**
 *   This test case aims to assess the macros CALLSUPER and SUPERMETHOD. 
 *   These macros are auto-generated by CRT specifically for redefined transitions and guards. 
 *   It ensures that these macros are present only for redefining elements and not for other locally defined elements that do not redefine an inherited element
 */
capsule TopBase {
    [[rt::decl]]
    `
    protected:
        bool _initialCalled = false;
        bool _transitionTimeoutCalled = false;
        int count = 0;
    `

    behavior port timer : Timing;
    behavior port timer2 : Timing;
    behavior port timer3 : Timing;

    statemachine {
        state State, State2, State3, Done {
            entry `PASS();`;
        };
        choice choice1;

        _initial: initial -> State 
        `
            _initialCalled = true;
        `;
        
        transitionTimeout : State -> State2 on timer.timeout 
        `
            _transitionTimeoutCalled = true;
        `;
        
        transitionTimeout3: State3 -> choice1 on timer3.timeout ;
        
        else: choice1 -> Done when `else`;

        onCheckOne: choice1 -> State3 when 
        `
            return count < 2;
        `;
    };
};

capsule Top : TopBase {
    statemachine {
        redefine _initial:initial -> State 
        `
            std::cout << "## _initial transition "  << std::endl;

            #ifndef CALLSUPER
                FAIL("CALLSUPER not initialized in _initial; expected to be defined on redefined transition");
            #endif

            #ifndef SUPERMETHOD
                FAIL("SUPERMETHOD not initialized in _initial; expected to be defined on redefined transition");
            #endif

            // _initialCalled is set to false; the test should pass only if the parent function is called and _initialCalled is set to true
            _initialCalled = false;
            CALLSUPER;
            ASSERT(_initialCalled, "CALLSUPER not called in _initial as expected");

            // _initialCalled is set to false; the test should pass only if the parent function is called and _initialCalled is set to true
            _initialCalled = false;
            SUPERMETHOD(rtdata, rtport);
            ASSERT(_initialCalled, "SUPERMETHOD not called in _initial as expected");
            timer.informIn(RTTimespec(0,50));
        `;

        redefine transitionTimeout : State -> State2 on timer.timeout 
        `
            std::cout << "## transitionTimeout transition "  << std::endl;

            #ifndef CALLSUPER
                FAIL("CALLSUPER not initialized in transitionTimeout; expected to be defined on redefined transition");
            #endif

            #ifndef SUPERMETHOD
                FAIL("SUPERMETHOD not initialized in transitionTimeout; expected to be defined on redefined transition");
            #endif

            // _transitionTimeoutCalled is set to false; the test should pass only if the parent function is called and _transitionTimeoutCalled is set to true
            _transitionTimeoutCalled = false;
            CALLSUPER;
            ASSERT(_transitionTimeoutCalled, "CALLSUPER not called in transitionTimeout as expected");

            // _transitionTimeoutCalled is set to false; the test should pass only if the parent function is called and _transitionTimeoutCalled is set to true
            _transitionTimeoutCalled = false;
            SUPERMETHOD(rtdata, rtport);
            ASSERT(_transitionTimeoutCalled, "SUPERMETHOD not called in transitionTimeout as expected");
            timer2.informIn(RTTimespec(0,50));
        `;

        transitionTimeout2: State2 -> State3 on timer2.timeout 
        `
            std::cout << "## transitionTimeout2 - not redefined trastion "  << std::endl;
            #ifdef CALLSUPER
                FAIL("CALLSUPER should not be defined at not redefined trastion");
            #endif

            #ifdef SUPERMETHOD
                FAIL("SUPERMETHOD should not be defined at not redefined trastion");
            #endif
            timer3.informIn(RTTimespec(0,50));
        `;

        redefine transitionTimeout3: State3 -> choice1 on timer3.timeout 
        ` std::cout << "## transitionTimeout3 transition "  << std::endl;`;

        redefine else: choice1 -> Done when `else`;

        redefine onCheckOne: choice1 -> State3 when 
        `
            std::cout << "onCheckOne redefined guard " << count << std::endl;

            #ifndef CALLSUPER
                FAIL("CALLSUPER not defined on redefined guard");
            #endif

            #ifndef SUPERMETHOD
                FAIL("SUPERMETHOD not defined on redefined guard");
            #endif
            return count == 0;
        `
        // Effect code begin
        `
            std::cout << "#onCheckOne redefined transition"  << std::endl;

            #ifndef CALLSUPER
                FAIL("CALLSUPER not defined on redefined transition at choice");
            #endif

            #ifndef SUPERMETHOD
                FAIL("SUPERMETHOD not defined on redefined transition at choice");
            #endif
            count++;
            timer3.informIn(RTTimespec(0,50));
        `;
        
        onCheckTwo: choice1 -> State3 when `
            std::cout << "## onCheckTwo - not redefined guard"  << std::endl;
            #ifdef CALLSUPER
                FAIL("CALLSUPER should not be defined at not redefined guard");
            #endif

            #ifdef SUPERMETHOD
                FAIL("SUPERMETHOD should not be defined at not redefined guard");
            #endif
            return count == 1;
        `
        // Effect code begin
        `
            std::cout << "## onCheckTwo - not redefined transition at choice"  << std::endl;
            #ifdef CALLSUPER
                FAIL("CALLSUPER should not be defined in not redefined transition at choice");
            #endif
            #ifdef SUPERMETHOD
                FAIL("SUPERMETHOD should not be defined in not redefined transition at choice");
            #endif
            count++;
            timer3.informIn(RTTimespec(0,50));
        `;
    };
};
