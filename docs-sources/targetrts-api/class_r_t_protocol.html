<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ TargetRTS: RTProtocol Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C++ TargetRTS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_r_t_protocol-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">RTProtocol Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a general capsule port typed by a protocol which determines the set of events that can be sent to and received by the port.  
 <a href="class_r_t_protocol.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_r_t_protocol_8h_source.html">RTProtocol.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTProtocol:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_r_t_protocol.png" usemap="#RTProtocol_map" alt=""/>
  <map id="RTProtocol_map" name="RTProtocol_map">
<area href="class_exception_1_1_base.html" title="Represents an exception port through which exception events can be raised." alt="Exception::Base" shape="rect" coords="0,56,101,80"/>
<area href="class_external_1_1_base.html" title="Represents a port through which an external thread can safely communicate with its owner capsule." alt="External::Base" shape="rect" coords="111,56,212,80"/>
<area href="class_frame_1_1_base.html" title="Represents a frame port." alt="Frame::Base" shape="rect" coords="222,56,323,80"/>
<area href="class_log_1_1_base.html" title="Represents a log port." alt="Log::Base" shape="rect" coords="333,56,434,80"/>
<area href="class_r_t_root_protocol.html" title="Represents a capsule port which at run-time can be bound to another capsule port." alt="RTRootProtocol" shape="rect" coords="444,56,545,80"/>
<area href="class_timing_1_1_base.html" title="Represents a timer port." alt="Timing::Base" shape="rect" coords="555,56,656,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02358053723895c6423f73ec97d5fe24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_controller.html">RTController</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a02358053723895c6423f73ec97d5fe24">context</a> (void) const</td></tr>
<tr class="memdesc:a02358053723895c6423f73ec97d5fe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context of the capsule that owns this port.  <br /></td></tr>
<tr class="separator:a02358053723895c6423f73ec97d5fe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569d7ad23ba8a40313ebc91aee92cc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a7569d7ad23ba8a40313ebc91aee92cc4">getId</a> (void) const</td></tr>
<tr class="memdesc:a7569d7ad23ba8a40313ebc91aee92cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the port.  <br /></td></tr>
<tr class="separator:a7569d7ad23ba8a40313ebc91aee92cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13996e31840891910920c9880670edf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_port_descriptor.html">RTPortDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ab13996e31840891910920c9880670edf">getInfo</a> (void) const</td></tr>
<tr class="memdesc:ab13996e31840891910920c9880670edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about a port.  <br /></td></tr>
<tr class="separator:ab13996e31840891910920c9880670edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee715e514169058cc688ef652ec41f83"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aee715e514169058cc688ef652ec41f83">getName</a> (void) const</td></tr>
<tr class="memdesc:aee715e514169058cc688ef652ec41f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the port.  <br /></td></tr>
<tr class="separator:aee715e514169058cc688ef652ec41f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6545f036888aeacaab36096f4e876ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor.html">RTActor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#af6545f036888aeacaab36096f4e876ff">getOwner</a> (void) const</td></tr>
<tr class="memdesc:af6545f036888aeacaab36096f4e876ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the owner capsule to which the port belongs.  <br /></td></tr>
<tr class="separator:af6545f036888aeacaab36096f4e876ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf5a22f8232f12cd60a969523946889"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a1bf5a22f8232f12cd60a969523946889">size</a> (void) const</td></tr>
<tr class="memdesc:a1bf5a22f8232f12cd60a969523946889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the port.  <br /></td></tr>
<tr class="separator:a1bf5a22f8232f12cd60a969523946889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef50658d6d1246dee65718b70b1a2088"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aef50658d6d1246dee65718b70b1a2088">resize</a> (int new_size)</td></tr>
<tr class="memdesc:aef50658d6d1246dee65718b70b1a2088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new size (i.e.  <br /></td></tr>
<tr class="separator:aef50658d6d1246dee65718b70b1a2088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35cd8130dde852d13d7953419349a11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#af35cd8130dde852d13d7953419349a11">registerSAP</a> (const char *service)</td></tr>
<tr class="memdesc:af35cd8130dde852d13d7953419349a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port (SAP) with the layer service (as a "client").  <br /></td></tr>
<tr class="separator:af35cd8130dde852d13d7953419349a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e580b53c346f4a623b2864fcc8e344b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a5e580b53c346f4a623b2864fcc8e344b">deregisterSAP</a> (void)</td></tr>
<tr class="memdesc:a5e580b53c346f4a623b2864fcc8e344b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (SAP).  <br /></td></tr>
<tr class="separator:a5e580b53c346f4a623b2864fcc8e344b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb58413ecb8836fe47aa6c0069fb3cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aabb58413ecb8836fe47aa6c0069fb3cf">registerSPP</a> (const char *service)</td></tr>
<tr class="memdesc:aabb58413ecb8836fe47aa6c0069fb3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port (SPP) with the layer service (as the "provider").  <br /></td></tr>
<tr class="separator:aabb58413ecb8836fe47aa6c0069fb3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71503e6d0ec280fa95ea813db29f41e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa71503e6d0ec280fa95ea813db29f41e">deregisterSPP</a> (void)</td></tr>
<tr class="memdesc:aa71503e6d0ec280fa95ea813db29f41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (SPP).  <br /></td></tr>
<tr class="separator:aa71503e6d0ec280fa95ea813db29f41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d430e4ee11ed7438cb77d60faaba91f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a0d430e4ee11ed7438cb77d60faaba91f">defaultLayerName</a> (void) const</td></tr>
<tr class="memdesc:a0d430e4ee11ed7438cb77d60faaba91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default registration name for the port.  <br /></td></tr>
<tr class="separator:a0d430e4ee11ed7438cb77d60faaba91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c47b94180b9f30bf3e25bcfa55fe0d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2c47b94180b9f30bf3e25bcfa55fe0d0">isRegistered</a> (void) const</td></tr>
<tr class="memdesc:a2c47b94180b9f30bf3e25bcfa55fe0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the port is currently registered with the layer service or not.  <br /></td></tr>
<tr class="separator:a2c47b94180b9f30bf3e25bcfa55fe0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4759bbdb8fcd25545f463a9caf15961d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4759bbdb8fcd25545f463a9caf15961d">getRegisteredName</a> (void) const</td></tr>
<tr class="memdesc:a4759bbdb8fcd25545f463a9caf15961d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the registration name of the port.  <br /></td></tr>
<tr class="separator:a4759bbdb8fcd25545f463a9caf15961d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dafbdb3f5339378036a1f9800ac8b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ad0dafbdb3f5339378036a1f9800ac8b8">registerAs</a> (const char *service)</td></tr>
<tr class="memdesc:ad0dafbdb3f5339378036a1f9800ac8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port either as an SAP or SPP (depending on the "Publish" property of the port).  <br /></td></tr>
<tr class="separator:ad0dafbdb3f5339378036a1f9800ac8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed18e2ea1cd805cf48df1c4dda1a56df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aed18e2ea1cd805cf48df1c4dda1a56df">deregister</a> (void)</td></tr>
<tr class="memdesc:aed18e2ea1cd805cf48df1c4dda1a56df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (either an SAP or SPP).  <br /></td></tr>
<tr class="separator:aed18e2ea1cd805cf48df1c4dda1a56df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae364dd3d1d73dda4146f77cadd708d53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ae364dd3d1d73dda4146f77cadd708d53">isBoundAt</a> (int index) const</td></tr>
<tr class="memdesc:ae364dd3d1d73dda4146f77cadd708d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a port instance is currently connected to another port instance.  <br /></td></tr>
<tr class="separator:ae364dd3d1d73dda4146f77cadd708d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2765cfbbe1295b939a47ea0b9be991c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ab2765cfbbe1295b939a47ea0b9be991c">isIndexTo</a> (int index, <a class="el" href="class_r_t_actor.html">RTActor</a> *capsule) const</td></tr>
<tr class="memdesc:ab2765cfbbe1295b939a47ea0b9be991c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a port instance is currently connected to a port instance owned by a certain capsule instance.  <br /></td></tr>
<tr class="separator:ab2765cfbbe1295b939a47ea0b9be991c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f251e8160558cf5ae295a59cfab1202"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a7f251e8160558cf5ae295a59cfab1202">indexTo</a> (<a class="el" href="class_r_t_actor.html">RTActor</a> *capsule) const</td></tr>
<tr class="memdesc:a7f251e8160558cf5ae295a59cfab1202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if there exists a port instance currently connected to a port instance owned by a certain capsule instance.  <br /></td></tr>
<tr class="separator:a7f251e8160558cf5ae295a59cfab1202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9150bfbf17314443453d429c8f113553"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a9150bfbf17314443453d429c8f113553">purge</a> (void)</td></tr>
<tr class="memdesc:a9150bfbf17314443453d429c8f113553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the defer queue of all port instances without recalling any deferred message.  <br /></td></tr>
<tr class="separator:a9150bfbf17314443453d429c8f113553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2703f40abf6a8df9bbd730215c8c23e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2703f40abf6a8df9bbd730215c8c23e7">purgeAt</a> (int index)</td></tr>
<tr class="memdesc:a2703f40abf6a8df9bbd730215c8c23e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the defer queue of a specified port instance without recalling any deferred message.  <br /></td></tr>
<tr class="separator:a2703f40abf6a8df9bbd730215c8c23e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775cee0be2a2cfd90b58b2cc3ec0f86e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a775cee0be2a2cfd90b58b2cc3ec0f86e">recall</a> (void)</td></tr>
<tr class="memdesc:a775cee0be2a2cfd90b58b2cc3ec0f86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it at the back of the controller's message queue (after other queued messages).  <br /></td></tr>
<tr class="separator:a775cee0be2a2cfd90b58b2cc3ec0f86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae611db0412a09055815ac9717394f303"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ae611db0412a09055815ac9717394f303">recallFront</a> (void)</td></tr>
<tr class="memdesc:ae611db0412a09055815ac9717394f303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it at the front of the controller's message queue (before other queued messages).  <br /></td></tr>
<tr class="separator:ae611db0412a09055815ac9717394f303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7cfcb42423fc78b60f48f7220c0779"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a9f7cfcb42423fc78b60f48f7220c0779">recallAt</a> (int index, int front=0)</td></tr>
<tr class="memdesc:a9f7cfcb42423fc78b60f48f7220c0779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it in the controller's message queue.  <br /></td></tr>
<tr class="separator:a9f7cfcb42423fc78b60f48f7220c0779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc92df9cafd7c04372916ee4ef6c5c3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#afc92df9cafd7c04372916ee4ef6c5c3c">recallAll</a> (void)</td></tr>
<tr class="memdesc:afc92df9cafd7c04372916ee4ef6c5c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them at the back of the controller's message queue (after other queued messages).  <br /></td></tr>
<tr class="separator:afc92df9cafd7c04372916ee4ef6c5c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70638165fd32d634670c2c2f174a3c3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a70638165fd32d634670c2c2f174a3c3b">recallAllFront</a> (void)</td></tr>
<tr class="memdesc:a70638165fd32d634670c2c2f174a3c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them at the front of the controller's message queue (before other queued messages).  <br /></td></tr>
<tr class="separator:a70638165fd32d634670c2c2f174a3c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627afae9906e70cea7fc182bfb5f7cb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a627afae9906e70cea7fc182bfb5f7cb8">recallAllAt</a> (int index, int front=0)</td></tr>
<tr class="memdesc:a627afae9906e70cea7fc182bfb5f7cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them in the controller's message queue.  <br /></td></tr>
<tr class="separator:a627afae9906e70cea7fc182bfb5f7cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b78477128d033d1e1f4c797ef0caf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a56b78477128d033d1e1f4c797ef0caf6">bindingNotification</a> (int on_off)</td></tr>
<tr class="memdesc:a56b78477128d033d1e1f4c797ef0caf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off binding notifications for this port.  <br /></td></tr>
<tr class="separator:a56b78477128d033d1e1f4c797ef0caf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb72eaea84b5ce02ebf4393d1768c21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#adcb72eaea84b5ce02ebf4393d1768c21">bindingNotificationRequested</a> (void) const</td></tr>
<tr class="memdesc:adcb72eaea84b5ce02ebf4393d1768c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if binding notifications are currently enabled for the port.  <br /></td></tr>
<tr class="separator:adcb72eaea84b5ce02ebf4393d1768c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d444f5ca3150bf91f56cf1637623307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2d444f5ca3150bf91f56cf1637623307">sendTypeCheckEnable</a> (int on_off)</td></tr>
<tr class="memdesc:a2d444f5ca3150bf91f56cf1637623307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off type checking when performing <a class="el" href="class_r_t_protocol.html#a4b38472435fc60256e4a4f2d0234c9de" title="Send an event on the port.">send()</a>, <a class="el" href="class_r_t_protocol.html#a4fba0c4760d48842f11d891b416f3ef9" title="Invoke an event on the port.">invoke()</a> or <a class="el" href="class_r_t_protocol.html#a6458de033f1ecf9f60de9b7745dc376f" title="Make a reply to respond to an invoke.">reply()</a> on the port.  <br /></td></tr>
<tr class="separator:a2d444f5ca3150bf91f56cf1637623307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880d97d0e3b87ac9ea00bb2f6eaf0d56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a880d97d0e3b87ac9ea00bb2f6eaf0d56">sendTypeCheckEnabled</a> (void) const</td></tr>
<tr class="memdesc:a880d97d0e3b87ac9ea00bb2f6eaf0d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if type checking when sending events is enabled.  <br /></td></tr>
<tr class="separator:a880d97d0e3b87ac9ea00bb2f6eaf0d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa"><td class="memItemLeft" align="right" valign="top">RTProtocolDescriptor::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a1d2a9a51d2ec8c9f97dd6eb8e8370aaa">sendCheck</a> (int signal, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type) const</td></tr>
<tr class="memdesc:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a particular event would be possible to send on this port.  <br /></td></tr>
<tr class="separator:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac415448c9272ba92ead19c6e97c806bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ac415448c9272ba92ead19c6e97c806bd">receiveTypeCheckEnable</a> (int on_off)</td></tr>
<tr class="memdesc:ac415448c9272ba92ead19c6e97c806bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off type checking when receiving an event on the port.  <br /></td></tr>
<tr class="separator:ac415448c9272ba92ead19c6e97c806bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e0bd91743d6720c1ea3426074314e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a74e0bd91743d6720c1ea3426074314e7">receiveTypeCheckEnabled</a> (void) const</td></tr>
<tr class="memdesc:a74e0bd91743d6720c1ea3426074314e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if type checking when receiving events is enabled.  <br /></td></tr>
<tr class="separator:a74e0bd91743d6720c1ea3426074314e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ad300424f58e0f6325fdee64fe02d8"><td class="memItemLeft" align="right" valign="top">RTProtocolDescriptor::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa2ad300424f58e0f6325fdee64fe02d8">receiveCheck</a> (int signal, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type) const</td></tr>
<tr class="memdesc:aa2ad300424f58e0f6325fdee64fe02d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a particular event would be possible to receive on this port.  <br /></td></tr>
<tr class="separator:aa2ad300424f58e0f6325fdee64fe02d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fba0c4760d48842f11d891b416f3ef9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4fba0c4760d48842f11d891b416f3ef9">invoke</a> (<a class="el" href="class_r_t_message.html">RTMessage</a> *replyBuffer, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, bool implicitReply)</td></tr>
<tr class="memdesc:a4fba0c4760d48842f11d891b416f3ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke an event on the port.  <br /></td></tr>
<tr class="separator:a4fba0c4760d48842f11d891b416f3ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c5eae9cdc5ab117f9332b41964bcf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa3c5eae9cdc5ab117f9332b41964bcf7">invokeAt</a> (int index, <a class="el" href="class_r_t_message.html">RTMessage</a> *replyBuffer, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, bool implicitReply)</td></tr>
<tr class="memdesc:aa3c5eae9cdc5ab117f9332b41964bcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke an event on a replicated port at a specified index.  <br /></td></tr>
<tr class="separator:aa3c5eae9cdc5ab117f9332b41964bcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6458de033f1ecf9f60de9b7745dc376f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a6458de033f1ecf9f60de9b7745dc376f">reply</a> (int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type)</td></tr>
<tr class="memdesc:a6458de033f1ecf9f60de9b7745dc376f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a reply to respond to an invoke.  <br /></td></tr>
<tr class="separator:a6458de033f1ecf9f60de9b7745dc376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b38472435fc60256e4a4f2d0234c9de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4b38472435fc60256e4a4f2d0234c9de">send</a> (int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int priority, bool moveData=false)</td></tr>
<tr class="memdesc:a4b38472435fc60256e4a4f2d0234c9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event on the port.  <br /></td></tr>
<tr class="separator:a4b38472435fc60256e4a4f2d0234c9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d071f7137ca82a8ffd7c8e589c3114"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a77d071f7137ca82a8ffd7c8e589c3114">sendAt</a> (int index, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int priority, bool moveData=false)</td></tr>
<tr class="memdesc:a77d071f7137ca82a8ffd7c8e589c3114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event on a replicated port at a specified index.  <br /></td></tr>
<tr class="separator:a77d071f7137ca82a8ffd7c8e589c3114"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:aa9db557a5ebfcf5b8eceedd15dc0e5d5"><td class="memItemLeft" align="right" valign="top"><a id="aa9db557a5ebfcf5b8eceedd15dc0e5d5" name="aa9db557a5ebfcf5b8eceedd15dc0e5d5"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>BindingNotification</b> = 1
, <b>RegisteredAsSAP</b> = 2
, <b>SendTypeCheck</b> = 4
, <b>ReceiveTypeCheck</b> = 8
, <br />
&#160;&#160;<b>Resized</b> = 16
<br />
 }</td></tr>
<tr class="separator:aa9db557a5ebfcf5b8eceedd15dc0e5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bf1044e6f75455f11dd4edce2af616"><td class="memItemLeft" align="right" valign="top"><a id="ae3bf1044e6f75455f11dd4edce2af616" name="ae3bf1044e6f75455f11dd4edce2af616"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>rtiLast_RTProtocol</b> = 0
 }</td></tr>
<tr class="separator:ae3bf1044e6f75455f11dd4edce2af616"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac7a17e8dc831575b8b324c123af2b0da"><td class="memItemLeft" align="right" valign="top"><a id="ac7a17e8dc831575b8b324c123af2b0da" name="ac7a17e8dc831575b8b324c123af2b0da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (const <a class="el" href="struct_r_t_port_descriptor.html">RTPortDescriptor</a> *)</td></tr>
<tr class="separator:ac7a17e8dc831575b8b324c123af2b0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab821319dd07a3ef521765d9260783898"><td class="memItemLeft" align="right" valign="top"><a id="ab821319dd07a3ef521765d9260783898" name="ab821319dd07a3ef521765d9260783898"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFlags</b> (void) const</td></tr>
<tr class="separator:ab821319dd07a3ef521765d9260783898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13b117f2c7538cb426e361fba7426ef"><td class="memItemLeft" align="right" valign="top"><a id="ab13b117f2c7538cb426e361fba7426ef" name="ab13b117f2c7538cb426e361fba7426ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setFlag</b> (int)</td></tr>
<tr class="separator:ab13b117f2c7538cb426e361fba7426ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc08d99d20ab533b5079e3aa074e892"><td class="memItemLeft" align="right" valign="top"><a id="acbc08d99d20ab533b5079e3aa074e892" name="acbc08d99d20ab533b5079e3aa074e892"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetFlag</b> (int)</td></tr>
<tr class="separator:acbc08d99d20ab533b5079e3aa074e892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8e009f25cb11e3f94b3e8b1a03e885"><td class="memItemLeft" align="right" valign="top"><a id="a1b8e009f25cb11e3f94b3e8b1a03e885" name="a1b8e009f25cb11e3f94b3e8b1a03e885"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bindAt</b> (int, <a class="el" href="struct_r_t_binding_end.html">RTBindingEnd</a> &amp;, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:a1b8e009f25cb11e3f94b3e8b1a03e885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab999150c4dc37ce4cbc4390b847f39fb"><td class="memItemLeft" align="right" valign="top"><a id="ab999150c4dc37ce4cbc4390b847f39fb" name="ab999150c4dc37ce4cbc4390b847f39fb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>peerAt</b> (int, <a class="el" href="struct_r_t_binding_end.html">RTBindingEnd</a> &amp;)</td></tr>
<tr class="separator:ab999150c4dc37ce4cbc4390b847f39fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12e8428f1305054a5ddf074f19b595a"><td class="memItemLeft" align="right" valign="top"><a id="ae12e8428f1305054a5ddf074f19b595a" name="ae12e8428f1305054a5ddf074f19b595a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unbindAt</b> (int, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:ae12e8428f1305054a5ddf074f19b595a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7adb291e96c24590673c557299d052e"><td class="memItemLeft" align="right" valign="top"><a id="aa7adb291e96c24590673c557299d052e" name="aa7adb291e96c24590673c557299d052e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>notifyInit</b> (<a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:aa7adb291e96c24590673c557299d052e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2536ee9af988c7bebd23c626cb3f4898"><td class="memItemLeft" align="right" valign="top"><a id="a2536ee9af988c7bebd23c626cb3f4898" name="a2536ee9af988c7bebd23c626cb3f4898"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>notifyBoundAt</b> (int, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:a2536ee9af988c7bebd23c626cb3f4898"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6f65fa7d7adfc3c4f62b1c5d2b276cde"><td class="memItemLeft" align="right" valign="top"><a id="a6f65fa7d7adfc3c4f62b1c5d2b276cde" name="a6f65fa7d7adfc3c4f62b1c5d2b276cde"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>End</b></td></tr>
<tr class="separator:a6f65fa7d7adfc3c4f62b1c5d2b276cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa644bc916a7ca31a4149961f3ad64ff6"><td class="memItemLeft" align="right" valign="top"><a id="aa644bc916a7ca31a4149961f3ad64ff6" name="aa644bc916a7ca31a4149961f3ad64ff6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RTActor</b></td></tr>
<tr class="separator:aa644bc916a7ca31a4149961f3ad64ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f686b54c837122ffe208c46806481ea"><td class="memItemLeft" align="right" valign="top"><a id="a8f686b54c837122ffe208c46806481ea" name="a8f686b54c837122ffe208c46806481ea"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RTActorProbe</b></td></tr>
<tr class="separator:a8f686b54c837122ffe208c46806481ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632282972b0b5f6cd394a261964435e2"><td class="memItemLeft" align="right" valign="top"><a id="a632282972b0b5f6cd394a261964435e2" name="a632282972b0b5f6cd394a261964435e2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RTDebugger</b></td></tr>
<tr class="separator:a632282972b0b5f6cd394a261964435e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1314ca45caee52459c16d339938aa90b"><td class="memItemLeft" align="right" valign="top"><a id="a1314ca45caee52459c16d339938aa90b" name="a1314ca45caee52459c16d339938aa90b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RTLayerConnector</b></td></tr>
<tr class="separator:a1314ca45caee52459c16d339938aa90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aab5956bf8c8d6ec8620c660113a9f"><td class="memItemLeft" align="right" valign="top"><a id="ad7aab5956bf8c8d6ec8620c660113a9f" name="ad7aab5956bf8c8d6ec8620c660113a9f"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>RTExceptionSignal</b></td></tr>
<tr class="separator:ad7aab5956bf8c8d6ec8620c660113a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac281f18ff703e97842320e4bbc6f1bc3"><td class="memItemLeft" align="right" valign="top"><a id="ac281f18ff703e97842320e4bbc6f1bc3" name="ac281f18ff703e97842320e4bbc6f1bc3"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>RTInSignal</b></td></tr>
<tr class="separator:ac281f18ff703e97842320e4bbc6f1bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc35f44acec83a764bca88fe399028f"><td class="memItemLeft" align="right" valign="top"><a id="a5dc35f44acec83a764bca88fe399028f" name="a5dc35f44acec83a764bca88fe399028f"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>RTOutSignal</b></td></tr>
<tr class="separator:a5dc35f44acec83a764bca88fe399028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab242a96be7ae97f15d5f21caa79da27d"><td class="memItemLeft" align="right" valign="top"><a id="ab242a96be7ae97f15d5f21caa79da27d" name="ab242a96be7ae97f15d5f21caa79da27d"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>RTSymmetricSignal</b></td></tr>
<tr class="separator:ab242a96be7ae97f15d5f21caa79da27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a general capsule port typed by a protocol which determines the set of events that can be sent to and received by the port. </p>
<p>All specific protocols inherit from <a class="el" href="class_r_t_protocol.html" title="Represents a general capsule port typed by a protocol which determines the set of events that can be ...">RTProtocol</a>, which means that the functions of this class can be called on any capsule port regardless of which protocol it is typed by. For all protocols defined in the application two subclasses of <a class="el" href="class_r_t_protocol.html" title="Represents a general capsule port typed by a protocol which determines the set of events that can be ...">RTProtocol</a> are generated; one for each direction of communication using the events defined in the protocol. For a protocol X these subclasses are X::Base and X::Conjugate. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a56b78477128d033d1e1f4c797ef0caf6" name="a56b78477128d033d1e1f4c797ef0caf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b78477128d033d1e1f4c797ef0caf6">&#9670;&#160;</a></span>bindingNotification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTProtocol::bindingNotification </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on_off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on or off binding notifications for this port. </p>
<p>When such notifications are turned on the port will receive the 'rtBound' and 'rtUnbound' messages each time a port instance gets connected to (bound) or disconnected from (unbound) a remote port instance. Note that no messages are sent for port instances that are bound prior to the call of this function. Also note that turning off binding notifications will not purge 'rtBound' and 'rtUnbound' messages that have already been queued. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_off</td><td>Set to 0 to turn off binding notifications for the port, and 1 (or any non-zero value) to turn them on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcb72eaea84b5ce02ebf4393d1768c21" name="adcb72eaea84b5ce02ebf4393d1768c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb72eaea84b5ce02ebf4393d1768c21">&#9670;&#160;</a></span>bindingNotificationRequested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::bindingNotificationRequested </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if binding notifications are currently enabled for the port. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if binding notifications have been turned on for this port, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a02358053723895c6423f73ec97d5fe24" name="a02358053723895c6423f73ec97d5fe24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02358053723895c6423f73ec97d5fe24">&#9670;&#160;</a></span>context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_controller.html">RTController</a> * RTProtocol::context </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the context of the capsule that owns this port. </p>
<dl class="section return"><dt>Returns</dt><dd>The controller that runs the capsule instance to which this port belongs. </dd></dl>

</div>
</div>
<a id="a0d430e4ee11ed7438cb77d60faaba91f" name="a0d430e4ee11ed7438cb77d60faaba91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d430e4ee11ed7438cb77d60faaba91f">&#9670;&#160;</a></span>defaultLayerName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * RTProtocol::defaultLayerName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default registration name for the port. </p>
<dl class="section return"><dt>Returns</dt><dd>The default registration name specified for the unwired port. This corresponds to the port property "Registration Override". </dd></dl>

</div>
</div>
<a id="aed18e2ea1cd805cf48df1c4dda1a56df" name="aed18e2ea1cd805cf48df1c4dda1a56df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed18e2ea1cd805cf48df1c4dda1a56df">&#9670;&#160;</a></span>deregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::deregister </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deregister an unwired port (either an SAP or SPP). </p>
<p>This is equivalent of calling <a class="el" href="class_r_t_protocol.html#a5e580b53c346f4a623b2864fcc8e344b" title="Deregister an unwired port (SAP).">deregisterSAP()</a> or <a class="el" href="class_r_t_protocol.html#aa71503e6d0ec280fa95ea813db29f41e" title="Deregister an unwired port (SPP).">deregisterSPP()</a>. </p><dl class="section return"><dt>Returns</dt><dd>1 if deregistration was successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a5e580b53c346f4a623b2864fcc8e344b" name="a5e580b53c346f4a623b2864fcc8e344b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e580b53c346f4a623b2864fcc8e344b">&#9670;&#160;</a></span>deregisterSAP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::deregisterSAP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deregister an unwired port (SAP). </p>
<p>If the port is currently connected to an SPP, the connection will be terminated. </p><dl class="section return"><dt>Returns</dt><dd>1 if deregistration was successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="aa71503e6d0ec280fa95ea813db29f41e" name="aa71503e6d0ec280fa95ea813db29f41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71503e6d0ec280fa95ea813db29f41e">&#9670;&#160;</a></span>deregisterSPP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::deregisterSPP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deregister an unwired port (SPP). </p>
<p>If the port is currently connected to SPPs, all those connections will be terminated. </p><dl class="section return"><dt>Returns</dt><dd>1 if deregistration was successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a7569d7ad23ba8a40313ebc91aee92cc4" name="a7569d7ad23ba8a40313ebc91aee92cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7569d7ad23ba8a40313ebc91aee92cc4">&#9670;&#160;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::getId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the id of the port. </p>
<dl class="section return"><dt>Returns</dt><dd>An id that is unique among all the ports of the owner capsule. </dd></dl>

</div>
</div>
<a id="ab13996e31840891910920c9880670edf" name="ab13996e31840891910920c9880670edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13996e31840891910920c9880670edf">&#9670;&#160;</a></span>getInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_r_t_port_descriptor.html">RTPortDescriptor</a> * RTProtocol::getInfo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about a port. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_r_t_port_descriptor.html">RTPortDescriptor</a> object that contains information about the port. This information is static and is constituted by properties of the port definition, such as the name of the port. </dd></dl>

</div>
</div>
<a id="aee715e514169058cc688ef652ec41f83" name="aee715e514169058cc688ef652ec41f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee715e514169058cc688ef652ec41f83">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * RTProtocol::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the port. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the port. </dd></dl>

</div>
</div>
<a id="af6545f036888aeacaab36096f4e876ff" name="af6545f036888aeacaab36096f4e876ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6545f036888aeacaab36096f4e876ff">&#9670;&#160;</a></span>getOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor.html">RTActor</a> * RTProtocol::getOwner </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the owner capsule to which the port belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="class_r_t_actor.html" title="An instance of this class represents a capsule instance.">RTActor</a> representing the capsule to which this port belongs. </dd></dl>

</div>
</div>
<a id="a4759bbdb8fcd25545f463a9caf15961d" name="a4759bbdb8fcd25545f463a9caf15961d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4759bbdb8fcd25545f463a9caf15961d">&#9670;&#160;</a></span>getRegisteredName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * RTProtocol::getRegisteredName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the registration name of the port. </p>
<dl class="section return"><dt>Returns</dt><dd>The name under which the unwired port is currently registered with the layer service. </dd></dl>

</div>
</div>
<a id="a7f251e8160558cf5ae295a59cfab1202" name="a7f251e8160558cf5ae295a59cfab1202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f251e8160558cf5ae295a59cfab1202">&#9670;&#160;</a></span>indexTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::indexTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor.html">RTActor</a> *&#160;</td>
          <td class="paramname"><em>capsule</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if there exists a port instance currently connected to a port instance owned by a certain capsule instance. </p>
<p>If so, the index of the first found matching port instance is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capsule</td><td>Capsule instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest index found for a port instance connected to another port instance that is owned by the specified capsule instance. -1 if no such port instance exists. </dd></dl>

</div>
</div>
<a id="a4fba0c4760d48842f11d891b416f3ef9" name="a4fba0c4760d48842f11d891b416f3ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fba0c4760d48842f11d891b416f3ef9">&#9670;&#160;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_message.html">RTMessage</a> *&#160;</td>
          <td class="paramname"><em>replyBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>implicitReply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke an event on the port. </p>
<p>Normally you should not call this function directly, but instead call RTOutsignal::invoke() because it will provide most of the needed parameters for you. However, if you need to programatically invoke on a general port based on descriptor info this function can be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replyBuffer</td><td>A caller-supplied message object that stores the reply message(s) resulting from the invoke. The caller is responsible for allocating and deleting the message(s) when they are no longer required. To verify that a returned message is valid call <a class="el" href="class_r_t_message.html#af6227985d9f163c7fc83a8d8a27fbaf2" title="A message is considered valid as soon as its protocol event (i.e.">RTMessage::isValid()</a> once the invoke returns. </td></tr>
    <tr><td class="paramname">signal</td><td>The id of the event to invoke </td></tr>
    <tr><td class="paramname">data</td><td>Data object to pass with the invoke </td></tr>
    <tr><td class="paramname">type</td><td>Type descriptor describing the data object </td></tr>
    <tr><td class="paramname">implicitReply</td><td>Whether it should be allowed for the receiver to not make a reply call if no data needs to be passed back to the sender. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the invoke was successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="aa3c5eae9cdc5ab117f9332b41964bcf7" name="aa3c5eae9cdc5ab117f9332b41964bcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c5eae9cdc5ab117f9332b41964bcf7">&#9670;&#160;</a></span>invokeAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::invokeAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_message.html">RTMessage</a> *&#160;</td>
          <td class="paramname"><em>replyBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>implicitReply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke an event on a replicated port at a specified index. </p>
<p>Normally you should not call this function directly, but instead call RTOutsignal::invokeAt() because it will provide most of the needed parameters for you. However, if you need to programatically invoke on a general port based on descriptor info this function can be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The 0-based index of the port instance within the port on which to perform the invoke (0 &lt;= index &lt; <a class="el" href="class_r_t_protocol.html#a1bf5a22f8232f12cd60a969523946889" title="Get the size of the port.">size()</a>) </td></tr>
    <tr><td class="paramname">replyBuffer</td><td>A caller-supplied message object that stores the reply message(s) resulting from the invoke. The caller is responsible for allocating and deleting the message(s) when they are no longer required. To verify that a returned message is valid call <a class="el" href="class_r_t_message.html#af6227985d9f163c7fc83a8d8a27fbaf2" title="A message is considered valid as soon as its protocol event (i.e.">RTMessage::isValid()</a> once the invoke returns. </td></tr>
    <tr><td class="paramname">signal</td><td>The id of the event to invoke </td></tr>
    <tr><td class="paramname">data</td><td>Data object to pass with the invoke </td></tr>
    <tr><td class="paramname">type</td><td>Type descriptor describing the data object </td></tr>
    <tr><td class="paramname">implicitReply</td><td>Whether it should be allowed for the receiver to not make a reply call if no data needs to be passed back to the sender. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the invoke was successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ae364dd3d1d73dda4146f77cadd708d53" name="ae364dd3d1d73dda4146f77cadd708d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae364dd3d1d73dda4146f77cadd708d53">&#9670;&#160;</a></span>isBoundAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::isBoundAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a port instance is currently connected to another port instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>0-based index of the port instance within the port (0 &lt;= index &lt; <a class="el" href="class_r_t_protocol.html#a1bf5a22f8232f12cd60a969523946889" title="Get the size of the port.">size()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the port instance at the specified index is connected to another port instance. 0 if it is not connected. </dd></dl>

</div>
</div>
<a id="ab2765cfbbe1295b939a47ea0b9be991c" name="ab2765cfbbe1295b939a47ea0b9be991c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2765cfbbe1295b939a47ea0b9be991c">&#9670;&#160;</a></span>isIndexTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::isIndexTo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_actor.html">RTActor</a> *&#160;</td>
          <td class="paramname"><em>capsule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a port instance is currently connected to a port instance owned by a certain capsule instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>0-based index of the port instance within the port (0 &lt;= index &lt; <a class="el" href="class_r_t_protocol.html#a1bf5a22f8232f12cd60a969523946889" title="Get the size of the port.">size()</a>) </td></tr>
    <tr><td class="paramname">capsule</td><td>Capsule instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the port instance at the specified index is connected to another port instance that is owned by the specified capsule instance. 0 if not. </dd></dl>

</div>
</div>
<a id="a2c47b94180b9f30bf3e25bcfa55fe0d0" name="a2c47b94180b9f30bf3e25bcfa55fe0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c47b94180b9f30bf3e25bcfa55fe0d0">&#9670;&#160;</a></span>isRegistered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::isRegistered </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the port is currently registered with the layer service or not. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the unwired port is currently registered with the layer service, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a9150bfbf17314443453d429c8f113553" name="a9150bfbf17314443453d429c8f113553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9150bfbf17314443453d429c8f113553">&#9670;&#160;</a></span>purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::purge </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the defer queue of all port instances without recalling any deferred message. </p>
<p>To delete deferred messages for one port instance only, use <a class="el" href="class_r_t_protocol.html#a2703f40abf6a8df9bbd730215c8c23e7" title="Empty the defer queue of a specified port instance without recalling any deferred message.">purgeAt()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The number of messages deleted from the defer queue. </dd></dl>

</div>
</div>
<a id="a2703f40abf6a8df9bbd730215c8c23e7" name="a2703f40abf6a8df9bbd730215c8c23e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2703f40abf6a8df9bbd730215c8c23e7">&#9670;&#160;</a></span>purgeAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::purgeAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the defer queue of a specified port instance without recalling any deferred message. </p>
<p>To delete deferred messages for all port instances, use <a class="el" href="class_r_t_protocol.html#a9150bfbf17314443453d429c8f113553" title="Empty the defer queue of all port instances without recalling any deferred message.">purge()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The number of messages deleted from the defer queue. </dd></dl>

</div>
</div>
<a id="a775cee0be2a2cfd90b58b2cc3ec0f86e" name="a775cee0be2a2cfd90b58b2cc3ec0f86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775cee0be2a2cfd90b58b2cc3ec0f86e">&#9670;&#160;</a></span>recall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::recall </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recall a message from the defer queue and insert it at the back of the controller's message queue (after other queued messages). </p>
<p>The recalled message can be for any port instance. </p><dl class="section return"><dt>Returns</dt><dd>The number of messages recalled from the defer queue (i.e. either 1 or 0). </dd></dl>

</div>
</div>
<a id="afc92df9cafd7c04372916ee4ef6c5c3c" name="afc92df9cafd7c04372916ee4ef6c5c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc92df9cafd7c04372916ee4ef6c5c3c">&#9670;&#160;</a></span>recallAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::recallAll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recall all messages from the defer queue and insert them at the back of the controller's message queue (after other queued messages). </p>
<p>The recalled messages can be for any port instance. </p><dl class="section return"><dt>Returns</dt><dd>The number of messages recalled from the defer queue. </dd></dl>

</div>
</div>
<a id="a627afae9906e70cea7fc182bfb5f7cb8" name="a627afae9906e70cea7fc182bfb5f7cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627afae9906e70cea7fc182bfb5f7cb8">&#9670;&#160;</a></span>recallAllAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::recallAllAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>front</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recall all messages from the defer queue and insert them in the controller's message queue. </p>
<p>By default the recalled messages are inserted at the back of the message queue. The recalled messages must be for the port instance at the specified index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the port instance for which to recall the messages. </td></tr>
    <tr><td class="paramname">front</td><td>Set this parameter to 1 to insert the recalled messages at the front of the message queue instead of at the back which is the default behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of messages recalled from the defer queue. </dd></dl>

</div>
</div>
<a id="a70638165fd32d634670c2c2f174a3c3b" name="a70638165fd32d634670c2c2f174a3c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70638165fd32d634670c2c2f174a3c3b">&#9670;&#160;</a></span>recallAllFront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::recallAllFront </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recall all messages from the defer queue and insert them at the front of the controller's message queue (before other queued messages). </p>
<p>The recalled messages can be for any port instance. </p><dl class="section return"><dt>Returns</dt><dd>The number of messages recalled from the defer queue. </dd></dl>

</div>
</div>
<a id="a9f7cfcb42423fc78b60f48f7220c0779" name="a9f7cfcb42423fc78b60f48f7220c0779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7cfcb42423fc78b60f48f7220c0779">&#9670;&#160;</a></span>recallAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::recallAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>front</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recall a message from the defer queue and insert it in the controller's message queue. </p>
<p>By default the recalled message is inserted at the back of the message queue. The recalled message must be for the port instance at the specified index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the port instance for which to recall a message. </td></tr>
    <tr><td class="paramname">front</td><td>Set this parameter to 1 to insert the recalled message at the front of the message queue instead of at the back which is the default behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of messages recalled from the defer queue (i.e. either 1 or 0). </dd></dl>

</div>
</div>
<a id="ae611db0412a09055815ac9717394f303" name="ae611db0412a09055815ac9717394f303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae611db0412a09055815ac9717394f303">&#9670;&#160;</a></span>recallFront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::recallFront </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recall a message from the defer queue and insert it at the front of the controller's message queue (before other queued messages). </p>
<p>The recalled message can be for any port instance. </p><dl class="section return"><dt>Returns</dt><dd>The number of messages recalled from the defer queue (i.e. either 1 or 0). </dd></dl>

</div>
</div>
<a id="aa2ad300424f58e0f6325fdee64fe02d8" name="aa2ad300424f58e0f6325fdee64fe02d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ad300424f58e0f6325fdee64fe02d8">&#9670;&#160;</a></span>receiveCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTProtocolDescriptor::Status RTProtocol::receiveCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a particular event would be possible to receive on this port. </p>
<p>If type checking is disabled no check is performed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td>The id of the event </td></tr>
    <tr><td class="paramname">type</td><td>The type descriptor of the event data, or 0 if the event does not have any data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A literal from the RTProtocolDescriptor::Status enum describing if the event could be received on the port or not. "ok" means it would be possible to receive the event. "badSignal" means the event is not an incoming (or outgoing if the port is conjugated) event in the protocol that types the port. "badType" means the type descriptor does not match the type specified for the protocol event. </dd></dl>

</div>
</div>
<a id="ac415448c9272ba92ead19c6e97c806bd" name="ac415448c9272ba92ead19c6e97c806bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac415448c9272ba92ead19c6e97c806bd">&#9670;&#160;</a></span>receiveTypeCheckEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTProtocol::receiveTypeCheckEnable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on_off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on or off type checking when receiving an event on the port. </p>
<p>Calling this function has no effect if the macro RTTYPECHECK_SEND has been set to RTTYPECHECK_DONT. Type checking is by default turned on for all ports and can help detect problems during development. However, the application will run slightly faster if you turn it off. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_off</td><td>Set to 0 to turn off type checking for the port, and 1 (or any non-zero value to turn it on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74e0bd91743d6720c1ea3426074314e7" name="a74e0bd91743d6720c1ea3426074314e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e0bd91743d6720c1ea3426074314e7">&#9670;&#160;</a></span>receiveTypeCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::receiveTypeCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if type checking when receiving events is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if type checking on event reception has been turned on for this port, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ad0dafbdb3f5339378036a1f9800ac8b8" name="ad0dafbdb3f5339378036a1f9800ac8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dafbdb3f5339378036a1f9800ac8b8">&#9670;&#160;</a></span>registerAs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::registerAs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an unwired port either as an SAP or SPP (depending on the "Publish" property of the port). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Be specific and use <a class="el" href="class_r_t_protocol.html#aabb58413ecb8836fe47aa6c0069fb3cf" title="Register an unwired port (SPP) with the layer service (as the &quot;provider&quot;).">registerSPP()</a> or <a class="el" href="class_r_t_protocol.html#af35cd8130dde852d13d7953419349a11" title="Register an unwired port (SAP) with the layer service (as a &quot;client&quot;).">registerSAP()</a> instead. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>1 on successful registration, 0 otherwise. </dd></dl>

</div>
</div>
<a id="af35cd8130dde852d13d7953419349a11" name="af35cd8130dde852d13d7953419349a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35cd8130dde852d13d7953419349a11">&#9670;&#160;</a></span>registerSAP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::registerSAP </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an unwired port (SAP) with the layer service (as a "client"). </p>
<p>If this function is invoked on an SAP which is already registered with a different name, then the original registered name is automatically deregistered, and the SAP is registered with the new name. Registering an SAP enables an SPP to later connect to it using the specified service name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>A string that is used to identify a unique service name under which SAPs and SPPs will connect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the registration of the service name was successful, and 0 otherwise. The registration fails if the port is not an unwired port. If the SAP is already registered with this same name, the function returns 1. </dd></dl>

</div>
</div>
<a id="aabb58413ecb8836fe47aa6c0069fb3cf" name="aabb58413ecb8836fe47aa6c0069fb3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb58413ecb8836fe47aa6c0069fb3cf">&#9670;&#160;</a></span>registerSPP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::registerSPP </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an unwired port (SPP) with the layer service (as the "provider"). </p>
<p>If this function is invoked on an SAP which is already registered with a different name, then the original registered name is automatically deregistered, and the SAP is registered with the new name. Registering an SPP enables SAPs to later connect to it using the specified service name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>A string that is used to identify a unique service name under which SAPs and SPPs will connect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the registration of the service name was successful, and 0 otherwise. The registration fails if the port is not an unwired port. If the SPP is already registered with this same name, the function returns 1. </dd></dl>

</div>
</div>
<a id="a6458de033f1ecf9f60de9b7745dc376f" name="a6458de033f1ecf9f60de9b7745dc376f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6458de033f1ecf9f60de9b7745dc376f">&#9670;&#160;</a></span>reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::reply </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a reply to respond to an invoke. </p>
<p>Normally you should not call this function directly, but instead call RTOutsignal::reply() because it will provide all of the needed parameters for you. However, if you need to programatically reply on a general port based on descriptor info this function can be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td>The id of the event to reply with </td></tr>
    <tr><td class="paramname">data</td><td>Data object to pass with the reply </td></tr>
    <tr><td class="paramname">type</td><td>Type descriptor describing the data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the reply was successful, 0 otherwise. </dd></dl>

</div>
</div>
<a id="aef50658d6d1246dee65718b70b1a2088" name="aef50658d6d1246dee65718b70b1a2088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef50658d6d1246dee65718b70b1a2088">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new size (i.e. </p>
<p>multiplicity) for the port. This can only be done on non-wired ports. Increasing the size gives room for more connections, while decreasing the size may lead to that some established connections will be dropped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>New size for the port. Must be &gt;= 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful and 0 if resizing fails (use <a class="el" href="class_r_t_actor.html#a99fc714d65414511c7355262511aef7f" title="Get the most recent error that occurred when using the TargetRTS.">RTActor::getError()</a> then to determine the cause for the failure. </dd></dl>

</div>
</div>
<a id="a4b38472435fc60256e4a4f2d0234c9de" name="a4b38472435fc60256e4a4f2d0234c9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b38472435fc60256e4a4f2d0234c9de">&#9670;&#160;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::send </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>moveData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an event on the port. </p>
<p>Normally you should not call this function directly, but instead call RTOutsignal::send() because it will provide most of the needed parameters for you. However, if you need to programatically send on a general port based on descriptor info this function can be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td>The id of the event to send </td></tr>
    <tr><td class="paramname">data</td><td>Data object to pass with the sent event </td></tr>
    <tr><td class="paramname">type</td><td>Type descriptor describing the data object </td></tr>
    <tr><td class="paramname">priority</td><td>The priority at which the event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
    <tr><td class="paramname">moveData</td><td>Set to true if you want the data object to be moved instead of copied when sending the event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the event was successfully sent, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a77d071f7137ca82a8ffd7c8e589c3114" name="a77d071f7137ca82a8ffd7c8e589c3114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d071f7137ca82a8ffd7c8e589c3114">&#9670;&#160;</a></span>sendAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::sendAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>moveData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an event on a replicated port at a specified index. </p>
<p>Normally you should not call this function directly, but instead call RTOutsignal::sendAt() because it will provide most of the needed parameters for you. However, if you need to programatically send on a general port based on descriptor info this function can be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The 0-based index of the port instance within the port on which to send the event (0 &lt;= index &lt; <a class="el" href="class_r_t_protocol.html#a1bf5a22f8232f12cd60a969523946889" title="Get the size of the port.">size()</a>) </td></tr>
    <tr><td class="paramname">signal</td><td>The id of the event to send </td></tr>
    <tr><td class="paramname">data</td><td>Data object to pass with the sent event </td></tr>
    <tr><td class="paramname">type</td><td>Type descriptor describing the data object </td></tr>
    <tr><td class="paramname">priority</td><td>The priority at which the event should be sent. A message priority is interpreted as its relative importance with respect to all other unprocessed messages on a thread. The priority evaluates to one of the defined global priority values. </td></tr>
    <tr><td class="paramname">moveData</td><td>Set to true if you want the data object to be moved instead of copied when sending the event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the event was successfully sent, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a1d2a9a51d2ec8c9f97dd6eb8e8370aaa" name="a1d2a9a51d2ec8c9f97dd6eb8e8370aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2a9a51d2ec8c9f97dd6eb8e8370aaa">&#9670;&#160;</a></span>sendCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTProtocolDescriptor::Status RTProtocol::sendCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a particular event would be possible to send on this port. </p>
<p>If type checking is disabled no check is performed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td>The id of the event </td></tr>
    <tr><td class="paramname">type</td><td>The type descriptor of the event data, or 0 if the event does not have any data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A literal from the RTProtocolDescriptor::Status enum describing if the event could be sent on the port or not. "ok" means it would be possible to send the event. "badSignal" means the event is not an outgoing (or incoming if the port is conjugated) event in the protocol that types the port. "badType" means the type descriptor does not match the type specified for the protocol event. </dd></dl>

</div>
</div>
<a id="a2d444f5ca3150bf91f56cf1637623307" name="a2d444f5ca3150bf91f56cf1637623307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d444f5ca3150bf91f56cf1637623307">&#9670;&#160;</a></span>sendTypeCheckEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTProtocol::sendTypeCheckEnable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on_off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on or off type checking when performing <a class="el" href="class_r_t_protocol.html#a4b38472435fc60256e4a4f2d0234c9de" title="Send an event on the port.">send()</a>, <a class="el" href="class_r_t_protocol.html#a4fba0c4760d48842f11d891b416f3ef9" title="Invoke an event on the port.">invoke()</a> or <a class="el" href="class_r_t_protocol.html#a6458de033f1ecf9f60de9b7745dc376f" title="Make a reply to respond to an invoke.">reply()</a> on the port. </p>
<p>Calling this function has no effect if the macro RTTYPECHECK_SEND has been set to RTTYPECHECK_DONT. Type checking is by default turned on for all ports and can help detect problems during development. However, the application will run slightly faster if you turn it off. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_off</td><td>Set to 0 to turn off type checking for the port, and 1 (or any non-zero value to turn it on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a880d97d0e3b87ac9ea00bb2f6eaf0d56" name="a880d97d0e3b87ac9ea00bb2f6eaf0d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880d97d0e3b87ac9ea00bb2f6eaf0d56">&#9670;&#160;</a></span>sendTypeCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::sendTypeCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if type checking when sending events is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if type checking when sending events has been turned on for this port, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a1bf5a22f8232f12cd60a969523946889" name="a1bf5a22f8232f12cd60a969523946889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf5a22f8232f12cd60a969523946889">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTProtocol::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the port. </p>
<dl class="section return"><dt>Returns</dt><dd>The replication factor of the port, i.e. the size as defined by the port multiplicity. This specifies the maximum number of port instances, which is also the maximum number of possible connections to remote port instances. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_r_t_protocol_8h_source.html">RTProtocol.h</a></li>
<li>RTProtocol.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
