<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ TargetRTS: Frame::Base Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C++ TargetRTS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="struct_frame.html">Frame</a></li><li class="navelem"><a class="el" href="class_frame_1_1_base.html">Base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_frame_1_1_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Frame::Base Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a frame service port.  
 <a href="class_frame_1_1_base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_r_t_frame_8h_source.html">RTFrame.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Frame::Base:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_frame_1_1_base.png" usemap="#Frame::Base_map" alt=""/>
  <map id="Frame::Base_map" name="Frame::Base_map">
<area href="class_r_t_protocol.html" title="Represents a general capsule port typed by a protocol which determines the set of events that can be ..." alt="RTProtocol" shape="rect" coords="0,0,82,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a07be3539821c3a830ed3239adfccfed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a07be3539821c3a830ed3239adfccfed6">incarnate</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp)</td></tr>
<tr class="memdesc:a07be3539821c3a830ed3239adfccfed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incarnates a capsule by creating an instance of the capsule in an optional capsule part.  <br /></td></tr>
<tr class="separator:a07be3539821c3a830ed3239adfccfed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314b65d73a6040eb1153909e2238e185"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a314b65d73a6040eb1153909e2238e185">incarnate</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;cap)</td></tr>
<tr class="memdesc:a314b65d73a6040eb1153909e2238e185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incarnates a capsule by creating an instance of the capsule in an optional capsule part.  <br /></td></tr>
<tr class="separator:a314b65d73a6040eb1153909e2238e185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafaa6fc5066d572068b068497646b7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#abafaa6fc5066d572068b068497646b7a">incarnate</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, <a class="el" href="class_r_t_controller.html">RTController</a> *controller, int index)</td></tr>
<tr class="memdesc:abafaa6fc5066d572068b068497646b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incarnates a capsule by creating an instance of the capsule in an optional capsule part.  <br /></td></tr>
<tr class="separator:abafaa6fc5066d572068b068497646b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8aa336e2bde505835c046811eccdbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a0c8aa336e2bde505835c046811eccdbb">incarnate</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;cap, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, <a class="el" href="class_r_t_controller.html">RTController</a> *controller, int index)</td></tr>
<tr class="memdesc:a0c8aa336e2bde505835c046811eccdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incarnates a capsule by creating an instance of the capsule in an optional capsule part.  <br /></td></tr>
<tr class="separator:a0c8aa336e2bde505835c046811eccdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a3a112ba0c13dffdaf249b5f9b910d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#ac0a3a112ba0c13dffdaf249b5f9b910d">incarnate</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;data, <a class="el" href="class_r_t_controller.html">RTController</a> *controller=nullptr, int index=-1)</td></tr>
<tr class="memdesc:ac0a3a112ba0c13dffdaf249b5f9b910d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incarnates a capsule by creating an instance of the capsule in an optional capsule part.  <br /></td></tr>
<tr class="separator:ac0a3a112ba0c13dffdaf249b5f9b910d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ece127551d69cffb999f4008d541984"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a6ece127551d69cffb999f4008d541984">incarnate</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;cap, const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;data, <a class="el" href="class_r_t_controller.html">RTController</a> *controller=nullptr, int index=-1)</td></tr>
<tr class="memdesc:a6ece127551d69cffb999f4008d541984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incarnates a capsule by creating an instance of the capsule in an optional capsule part.  <br /></td></tr>
<tr class="separator:a6ece127551d69cffb999f4008d541984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5061b37c597cebd1786548e4e4663afe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a5061b37c597cebd1786548e4e4663afe">incarnate</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;info, <a class="el" href="class_r_t_controller.html">RTController</a> *controller=nullptr, int index=-1)</td></tr>
<tr class="memdesc:a5061b37c597cebd1786548e4e4663afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incarnates a capsule by creating an instance of the capsule in an optional capsule part.  <br /></td></tr>
<tr class="separator:a5061b37c597cebd1786548e4e4663afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cdd3c957cff7c5068636024a375aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a55cdd3c957cff7c5068636024a375aec">incarnate</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;cap, const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;info, <a class="el" href="class_r_t_controller.html">RTController</a> *controller=nullptr, int index=-1)</td></tr>
<tr class="memdesc:a55cdd3c957cff7c5068636024a375aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incarnates a capsule by creating an instance of the capsule in an optional capsule part.  <br /></td></tr>
<tr class="separator:a55cdd3c957cff7c5068636024a375aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa0d901c0c7ea0006c841d2161a460f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a0aa0d901c0c7ea0006c841d2161a460f">incarnateCustom</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, <a class="el" href="class_r_t_actor_factory.html">RTActorFactory</a> &amp;factory, int index=-1)</td></tr>
<tr class="memdesc:a0aa0d901c0c7ea0006c841d2161a460f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incarnates a capsule by creating an instance of the capsule in an optional capsule part using a custom capsule factory for creating the capsule instance.  <br /></td></tr>
<tr class="separator:a0aa0d901c0c7ea0006c841d2161a460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0ce32307144afb0861274f8e11646c"><td class="memItemLeft" align="right" valign="top"><a id="a9f0ce32307144afb0861274f8e11646c" name="a9f0ce32307144afb0861274f8e11646c"></a>
<a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><b>incarnateCustom</b> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, <a class="el" href="class_r_t_actor_factory.html">RTActorFactory</a> &amp;&amp;factory, int index=-1)</td></tr>
<tr class="separator:a9f0ce32307144afb0861274f8e11646c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39322bc4f2d83da6cd22bdd6c40af51a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a39322bc4f2d83da6cd22bdd6c40af51a">incarnateCustom</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, <a class="el" href="class_r_t_actor_factory.html">RTActorFactory</a> &amp;factory, int index=-1)</td></tr>
<tr class="memdesc:a39322bc4f2d83da6cd22bdd6c40af51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incarnates a capsule by creating an instance of the capsule in an optional capsule part using a custom capsule factory for creating the capsule instance.  <br /></td></tr>
<tr class="separator:a39322bc4f2d83da6cd22bdd6c40af51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c2c342e8e5d57b069c806e82eb565e"><td class="memItemLeft" align="right" valign="top"><a id="a33c2c342e8e5d57b069c806e82eb565e" name="a33c2c342e8e5d57b069c806e82eb565e"></a>
<a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><b>incarnateCustom</b> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, <a class="el" href="class_r_t_actor_factory.html">RTActorFactory</a> &amp;&amp;factory, int index=-1)</td></tr>
<tr class="separator:a33c2c342e8e5d57b069c806e82eb565e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4035fe02a9096ae4157fd92986171737"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a4035fe02a9096ae4157fd92986171737">destroy</a> (<a class="el" href="class_r_t_actor_id.html">RTActorId</a> &amp;i)</td></tr>
<tr class="memdesc:a4035fe02a9096ae4157fd92986171737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a capsule instance.  <br /></td></tr>
<tr class="separator:a4035fe02a9096ae4157fd92986171737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc2649d7e6a4731e285edcf158c09ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#abbc2649d7e6a4731e285edcf158c09ac">destroy</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp)</td></tr>
<tr class="memdesc:abbc2649d7e6a4731e285edcf158c09ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all capsule instances contained in a certain capsule part.  <br /></td></tr>
<tr class="separator:abbc2649d7e6a4731e285edcf158c09ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba6a0fa29d13eed653f3fe619157287"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a3ba6a0fa29d13eed653f3fe619157287">import</a> (const <a class="el" href="class_r_t_actor_id.html">RTActorId</a> &amp;i, <a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp_dest, int index=-1)</td></tr>
<tr class="memdesc:a3ba6a0fa29d13eed653f3fe619157287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a capsule instance into a plug-in capsule part.  <br /></td></tr>
<tr class="separator:a3ba6a0fa29d13eed653f3fe619157287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af168da4bbb8e78c2ddd0d5557ac8eb26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#af168da4bbb8e78c2ddd0d5557ac8eb26">import</a> (<a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp_src, <a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp_dest, int index=-1)</td></tr>
<tr class="memdesc:af168da4bbb8e78c2ddd0d5557ac8eb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a capsule instance into a plug-in capsule part.  <br /></td></tr>
<tr class="separator:af168da4bbb8e78c2ddd0d5557ac8eb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cc4c11e574d401cb4fbcbb18614c82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a21cc4c11e574d401cb4fbcbb18614c82">deport</a> (const <a class="el" href="class_r_t_actor_id.html">RTActorId</a> &amp;i, <a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp)</td></tr>
<tr class="memdesc:a21cc4c11e574d401cb4fbcbb18614c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a capsule instance from a plug-in capsule part.  <br /></td></tr>
<tr class="separator:a21cc4c11e574d401cb4fbcbb18614c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81906fa782eb2b6459a0f068f044154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#af81906fa782eb2b6459a0f068f044154">incarnationsOf</a> (const <a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp)</td></tr>
<tr class="memdesc:af81906fa782eb2b6459a0f068f044154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all capsule instances contained in a certain capsule part.  <br /></td></tr>
<tr class="separator:af81906fa782eb2b6459a0f068f044154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf5762e13d02bac97389a6d832a4ab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a3bf5762e13d02bac97389a6d832a4ab3">incarnationAt</a> (const <a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;cp, int index)</td></tr>
<tr class="memdesc:a3bf5762e13d02bac97389a6d832a4ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a capsule instance contained in a certain capsule part.  <br /></td></tr>
<tr class="separator:a3bf5762e13d02bac97389a6d832a4ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d08050ba8e0711e3136eb6064f11510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor_id.html">RTActorId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a1d08050ba8e0711e3136eb6064f11510">me</a> (void)</td></tr>
<tr class="memdesc:a1d08050ba8e0711e3136eb6064f11510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the capsule instance that owns the frame service port.  <br /></td></tr>
<tr class="separator:a1d08050ba8e0711e3136eb6064f11510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26682baa7d0b8ff291200bf7c3e1b10"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#aa26682baa7d0b8ff291200bf7c3e1b10">myClass</a> (void)</td></tr>
<tr class="memdesc:aa26682baa7d0b8ff291200bf7c3e1b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the capsule instance that owns the frame service port.  <br /></td></tr>
<tr class="separator:aa26682baa7d0b8ff291200bf7c3e1b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82acc65c4100b16c785f5dfdb6371db1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a82acc65c4100b16c785f5dfdb6371db1">classOf</a> (const <a class="el" href="class_r_t_actor_id.html">RTActorId</a> &amp;instance)</td></tr>
<tr class="memdesc:a82acc65c4100b16c785f5dfdb6371db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of a certain capsule instance.  <br /></td></tr>
<tr class="separator:a82acc65c4100b16c785f5dfdb6371db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676b79ba62d1dd095147d19afbbe83dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a676b79ba62d1dd095147d19afbbe83dc">classIsKindOf</a> (const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;subClass, const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;superClass)</td></tr>
<tr class="memdesc:a676b79ba62d1dd095147d19afbbe83dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a capsule is the same or inherits from another capsule.  <br /></td></tr>
<tr class="separator:a676b79ba62d1dd095147d19afbbe83dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b553a95f5763a925a8db8e9a0f39bcd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_frame_1_1_base.html#a0b553a95f5763a925a8db8e9a0f39bcd">className</a> (const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;)</td></tr>
<tr class="memdesc:a0b553a95f5763a925a8db8e9a0f39bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a capsule type.  <br /></td></tr>
<tr class="separator:a0b553a95f5763a925a8db8e9a0f39bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_r_t_protocol"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_r_t_protocol')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_r_t_protocol.html">RTProtocol</a></td></tr>
<tr class="memitem:a02358053723895c6423f73ec97d5fe24 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_controller.html">RTController</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a02358053723895c6423f73ec97d5fe24">context</a> (void) const</td></tr>
<tr class="memdesc:a02358053723895c6423f73ec97d5fe24 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context of the capsule that owns this port.  <br /></td></tr>
<tr class="separator:a02358053723895c6423f73ec97d5fe24 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569d7ad23ba8a40313ebc91aee92cc4 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a7569d7ad23ba8a40313ebc91aee92cc4">getId</a> (void) const</td></tr>
<tr class="memdesc:a7569d7ad23ba8a40313ebc91aee92cc4 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the port.  <br /></td></tr>
<tr class="separator:a7569d7ad23ba8a40313ebc91aee92cc4 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13996e31840891910920c9880670edf inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_r_t_port_descriptor.html">RTPortDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ab13996e31840891910920c9880670edf">getInfo</a> (void) const</td></tr>
<tr class="memdesc:ab13996e31840891910920c9880670edf inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about a port.  <br /></td></tr>
<tr class="separator:ab13996e31840891910920c9880670edf inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee715e514169058cc688ef652ec41f83 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aee715e514169058cc688ef652ec41f83">getName</a> (void) const</td></tr>
<tr class="memdesc:aee715e514169058cc688ef652ec41f83 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the port.  <br /></td></tr>
<tr class="separator:aee715e514169058cc688ef652ec41f83 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6545f036888aeacaab36096f4e876ff inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_t_actor.html">RTActor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#af6545f036888aeacaab36096f4e876ff">getOwner</a> (void) const</td></tr>
<tr class="memdesc:af6545f036888aeacaab36096f4e876ff inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the owner capsule to which the port belongs.  <br /></td></tr>
<tr class="separator:af6545f036888aeacaab36096f4e876ff inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf5a22f8232f12cd60a969523946889 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a1bf5a22f8232f12cd60a969523946889">size</a> (void) const</td></tr>
<tr class="memdesc:a1bf5a22f8232f12cd60a969523946889 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the port.  <br /></td></tr>
<tr class="separator:a1bf5a22f8232f12cd60a969523946889 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef50658d6d1246dee65718b70b1a2088 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aef50658d6d1246dee65718b70b1a2088">resize</a> (int new_size)</td></tr>
<tr class="memdesc:aef50658d6d1246dee65718b70b1a2088 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new size (i.e.  <br /></td></tr>
<tr class="separator:aef50658d6d1246dee65718b70b1a2088 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35cd8130dde852d13d7953419349a11 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#af35cd8130dde852d13d7953419349a11">registerSAP</a> (const char *service)</td></tr>
<tr class="memdesc:af35cd8130dde852d13d7953419349a11 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port (SAP) with the layer service (as a "client").  <br /></td></tr>
<tr class="separator:af35cd8130dde852d13d7953419349a11 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e580b53c346f4a623b2864fcc8e344b inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a5e580b53c346f4a623b2864fcc8e344b">deregisterSAP</a> (void)</td></tr>
<tr class="memdesc:a5e580b53c346f4a623b2864fcc8e344b inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (SAP).  <br /></td></tr>
<tr class="separator:a5e580b53c346f4a623b2864fcc8e344b inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb58413ecb8836fe47aa6c0069fb3cf inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aabb58413ecb8836fe47aa6c0069fb3cf">registerSPP</a> (const char *service)</td></tr>
<tr class="memdesc:aabb58413ecb8836fe47aa6c0069fb3cf inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port (SPP) with the layer service (as the "provider").  <br /></td></tr>
<tr class="separator:aabb58413ecb8836fe47aa6c0069fb3cf inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71503e6d0ec280fa95ea813db29f41e inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa71503e6d0ec280fa95ea813db29f41e">deregisterSPP</a> (void)</td></tr>
<tr class="memdesc:aa71503e6d0ec280fa95ea813db29f41e inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (SPP).  <br /></td></tr>
<tr class="separator:aa71503e6d0ec280fa95ea813db29f41e inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d430e4ee11ed7438cb77d60faaba91f inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a0d430e4ee11ed7438cb77d60faaba91f">defaultLayerName</a> (void) const</td></tr>
<tr class="memdesc:a0d430e4ee11ed7438cb77d60faaba91f inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default registration name for the port.  <br /></td></tr>
<tr class="separator:a0d430e4ee11ed7438cb77d60faaba91f inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c47b94180b9f30bf3e25bcfa55fe0d0 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2c47b94180b9f30bf3e25bcfa55fe0d0">isRegistered</a> (void) const</td></tr>
<tr class="memdesc:a2c47b94180b9f30bf3e25bcfa55fe0d0 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the port is currently registered with the layer service or not.  <br /></td></tr>
<tr class="separator:a2c47b94180b9f30bf3e25bcfa55fe0d0 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4759bbdb8fcd25545f463a9caf15961d inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4759bbdb8fcd25545f463a9caf15961d">getRegisteredName</a> (void) const</td></tr>
<tr class="memdesc:a4759bbdb8fcd25545f463a9caf15961d inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the registration name of the port.  <br /></td></tr>
<tr class="separator:a4759bbdb8fcd25545f463a9caf15961d inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dafbdb3f5339378036a1f9800ac8b8 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ad0dafbdb3f5339378036a1f9800ac8b8">registerAs</a> (const char *service)</td></tr>
<tr class="memdesc:ad0dafbdb3f5339378036a1f9800ac8b8 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unwired port either as an SAP or SPP (depending on the "Publish" property set on the port in the model).  <br /></td></tr>
<tr class="separator:ad0dafbdb3f5339378036a1f9800ac8b8 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed18e2ea1cd805cf48df1c4dda1a56df inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aed18e2ea1cd805cf48df1c4dda1a56df">deregister</a> (void)</td></tr>
<tr class="memdesc:aed18e2ea1cd805cf48df1c4dda1a56df inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an unwired port (either an SAP or SPP).  <br /></td></tr>
<tr class="separator:aed18e2ea1cd805cf48df1c4dda1a56df inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae364dd3d1d73dda4146f77cadd708d53 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ae364dd3d1d73dda4146f77cadd708d53">isBoundAt</a> (int index) const</td></tr>
<tr class="memdesc:ae364dd3d1d73dda4146f77cadd708d53 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a port instance is currently connected to another port instance.  <br /></td></tr>
<tr class="separator:ae364dd3d1d73dda4146f77cadd708d53 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2765cfbbe1295b939a47ea0b9be991c inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ab2765cfbbe1295b939a47ea0b9be991c">isIndexTo</a> (int index, <a class="el" href="class_r_t_actor.html">RTActor</a> *capsule) const</td></tr>
<tr class="memdesc:ab2765cfbbe1295b939a47ea0b9be991c inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a port instance is currently connected to a port instance owned by a certain capsule instance.  <br /></td></tr>
<tr class="separator:ab2765cfbbe1295b939a47ea0b9be991c inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f251e8160558cf5ae295a59cfab1202 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a7f251e8160558cf5ae295a59cfab1202">indexTo</a> (<a class="el" href="class_r_t_actor.html">RTActor</a> *capsule) const</td></tr>
<tr class="memdesc:a7f251e8160558cf5ae295a59cfab1202 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if there exists a port instance currently connected to a port instance owned by a certain capsule instance.  <br /></td></tr>
<tr class="separator:a7f251e8160558cf5ae295a59cfab1202 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9150bfbf17314443453d429c8f113553 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a9150bfbf17314443453d429c8f113553">purge</a> (void)</td></tr>
<tr class="memdesc:a9150bfbf17314443453d429c8f113553 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the defer queue of all port instances without recalling any deferred message.  <br /></td></tr>
<tr class="separator:a9150bfbf17314443453d429c8f113553 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2703f40abf6a8df9bbd730215c8c23e7 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2703f40abf6a8df9bbd730215c8c23e7">purgeAt</a> (int index)</td></tr>
<tr class="memdesc:a2703f40abf6a8df9bbd730215c8c23e7 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the defer queue of a specified port instance without recalling any deferred message.  <br /></td></tr>
<tr class="separator:a2703f40abf6a8df9bbd730215c8c23e7 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775cee0be2a2cfd90b58b2cc3ec0f86e inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a775cee0be2a2cfd90b58b2cc3ec0f86e">recall</a> (void)</td></tr>
<tr class="memdesc:a775cee0be2a2cfd90b58b2cc3ec0f86e inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it at the back of the controller's message queue (after other queued messages).  <br /></td></tr>
<tr class="separator:a775cee0be2a2cfd90b58b2cc3ec0f86e inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae611db0412a09055815ac9717394f303 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ae611db0412a09055815ac9717394f303">recallFront</a> (void)</td></tr>
<tr class="memdesc:ae611db0412a09055815ac9717394f303 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it at the front of the controller's message queue (before other queued messages).  <br /></td></tr>
<tr class="separator:ae611db0412a09055815ac9717394f303 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7cfcb42423fc78b60f48f7220c0779 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a9f7cfcb42423fc78b60f48f7220c0779">recallAt</a> (int index, int front=0)</td></tr>
<tr class="memdesc:a9f7cfcb42423fc78b60f48f7220c0779 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a message from the defer queue and insert it in the controller's message queue.  <br /></td></tr>
<tr class="separator:a9f7cfcb42423fc78b60f48f7220c0779 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc92df9cafd7c04372916ee4ef6c5c3c inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#afc92df9cafd7c04372916ee4ef6c5c3c">recallAll</a> (void)</td></tr>
<tr class="memdesc:afc92df9cafd7c04372916ee4ef6c5c3c inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them at the back of the controller's message queue (after other queued messages).  <br /></td></tr>
<tr class="separator:afc92df9cafd7c04372916ee4ef6c5c3c inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70638165fd32d634670c2c2f174a3c3b inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a70638165fd32d634670c2c2f174a3c3b">recallAllFront</a> (void)</td></tr>
<tr class="memdesc:a70638165fd32d634670c2c2f174a3c3b inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them at the front of the controller's message queue (before other queued messages).  <br /></td></tr>
<tr class="separator:a70638165fd32d634670c2c2f174a3c3b inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627afae9906e70cea7fc182bfb5f7cb8 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a627afae9906e70cea7fc182bfb5f7cb8">recallAllAt</a> (int index, int front=0)</td></tr>
<tr class="memdesc:a627afae9906e70cea7fc182bfb5f7cb8 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall all messages from the defer queue and insert them in the controller's message queue.  <br /></td></tr>
<tr class="separator:a627afae9906e70cea7fc182bfb5f7cb8 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b78477128d033d1e1f4c797ef0caf6 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a56b78477128d033d1e1f4c797ef0caf6">bindingNotification</a> (int on_off)</td></tr>
<tr class="memdesc:a56b78477128d033d1e1f4c797ef0caf6 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off binding notifications for this port.  <br /></td></tr>
<tr class="separator:a56b78477128d033d1e1f4c797ef0caf6 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb72eaea84b5ce02ebf4393d1768c21 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#adcb72eaea84b5ce02ebf4393d1768c21">bindingNotificationRequested</a> (void) const</td></tr>
<tr class="memdesc:adcb72eaea84b5ce02ebf4393d1768c21 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if binding notifications are currently enabled for the port.  <br /></td></tr>
<tr class="separator:adcb72eaea84b5ce02ebf4393d1768c21 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d444f5ca3150bf91f56cf1637623307 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a2d444f5ca3150bf91f56cf1637623307">sendTypeCheckEnable</a> (int on_off)</td></tr>
<tr class="memdesc:a2d444f5ca3150bf91f56cf1637623307 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off type checking when performing <a class="el" href="class_r_t_protocol.html#a4b38472435fc60256e4a4f2d0234c9de" title="Send an event on the port.">send()</a>, <a class="el" href="class_r_t_protocol.html#a4fba0c4760d48842f11d891b416f3ef9" title="Invoke an event on the port.">invoke()</a> or <a class="el" href="class_r_t_protocol.html#a6458de033f1ecf9f60de9b7745dc376f" title="Make a reply to respond to an invoke.">reply()</a> on the port.  <br /></td></tr>
<tr class="separator:a2d444f5ca3150bf91f56cf1637623307 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880d97d0e3b87ac9ea00bb2f6eaf0d56 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a880d97d0e3b87ac9ea00bb2f6eaf0d56">sendTypeCheckEnabled</a> (void) const</td></tr>
<tr class="memdesc:a880d97d0e3b87ac9ea00bb2f6eaf0d56 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if type checking when sending events is enabled.  <br /></td></tr>
<tr class="separator:a880d97d0e3b87ac9ea00bb2f6eaf0d56 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">RTProtocolDescriptor::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a1d2a9a51d2ec8c9f97dd6eb8e8370aaa">sendCheck</a> (int signal, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type) const</td></tr>
<tr class="memdesc:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a particular event would be possible to send on this port.  <br /></td></tr>
<tr class="separator:a1d2a9a51d2ec8c9f97dd6eb8e8370aaa inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac415448c9272ba92ead19c6e97c806bd inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#ac415448c9272ba92ead19c6e97c806bd">receiveTypeCheckEnable</a> (int on_off)</td></tr>
<tr class="memdesc:ac415448c9272ba92ead19c6e97c806bd inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off type checking when receiving an event on the port.  <br /></td></tr>
<tr class="separator:ac415448c9272ba92ead19c6e97c806bd inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e0bd91743d6720c1ea3426074314e7 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a74e0bd91743d6720c1ea3426074314e7">receiveTypeCheckEnabled</a> (void) const</td></tr>
<tr class="memdesc:a74e0bd91743d6720c1ea3426074314e7 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if type checking when receiving events is enabled.  <br /></td></tr>
<tr class="separator:a74e0bd91743d6720c1ea3426074314e7 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ad300424f58e0f6325fdee64fe02d8 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">RTProtocolDescriptor::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa2ad300424f58e0f6325fdee64fe02d8">receiveCheck</a> (int signal, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type) const</td></tr>
<tr class="memdesc:aa2ad300424f58e0f6325fdee64fe02d8 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a particular event would be possible to receive on this port.  <br /></td></tr>
<tr class="separator:aa2ad300424f58e0f6325fdee64fe02d8 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fba0c4760d48842f11d891b416f3ef9 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4fba0c4760d48842f11d891b416f3ef9">invoke</a> (<a class="el" href="class_r_t_message.html">RTMessage</a> *replyBuffer, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, bool implicitReply)</td></tr>
<tr class="memdesc:a4fba0c4760d48842f11d891b416f3ef9 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke an event on the port.  <br /></td></tr>
<tr class="separator:a4fba0c4760d48842f11d891b416f3ef9 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c5eae9cdc5ab117f9332b41964bcf7 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#aa3c5eae9cdc5ab117f9332b41964bcf7">invokeAt</a> (int index, <a class="el" href="class_r_t_message.html">RTMessage</a> *replyBuffer, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, bool implicitReply)</td></tr>
<tr class="memdesc:aa3c5eae9cdc5ab117f9332b41964bcf7 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke an event on a replicated port at a specified index.  <br /></td></tr>
<tr class="separator:aa3c5eae9cdc5ab117f9332b41964bcf7 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6458de033f1ecf9f60de9b7745dc376f inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a6458de033f1ecf9f60de9b7745dc376f">reply</a> (int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type)</td></tr>
<tr class="memdesc:a6458de033f1ecf9f60de9b7745dc376f inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a reply to respond to an invoke.  <br /></td></tr>
<tr class="separator:a6458de033f1ecf9f60de9b7745dc376f inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b38472435fc60256e4a4f2d0234c9de inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a4b38472435fc60256e4a4f2d0234c9de">send</a> (int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int priority, bool moveData=false)</td></tr>
<tr class="memdesc:a4b38472435fc60256e4a4f2d0234c9de inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event on the port.  <br /></td></tr>
<tr class="separator:a4b38472435fc60256e4a4f2d0234c9de inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d071f7137ca82a8ffd7c8e589c3114 inherit pub_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_t_protocol.html#a77d071f7137ca82a8ffd7c8e589c3114">sendAt</a> (int index, int signal, const void *data, const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *type, int priority, bool moveData=false)</td></tr>
<tr class="memdesc:a77d071f7137ca82a8ffd7c8e589c3114 inherit pub_methods_class_r_t_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event on a replicated port at a specified index.  <br /></td></tr>
<tr class="separator:a77d071f7137ca82a8ffd7c8e589c3114 inherit pub_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a70653f2575375871860c60bc74fc8fec"><td class="memItemLeft" align="right" valign="top"><a id="a70653f2575375871860c60bc74fc8fec" name="a70653f2575375871860c60bc74fc8fec"></a>
static const <a class="el" href="struct_r_t_protocol_descriptor.html">RTProtocolDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rt_class</b></td></tr>
<tr class="separator:a70653f2575375871860c60bc74fc8fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_class_r_t_protocol"><td colspan="2" onclick="javascript:toggleInherit('pro_types_class_r_t_protocol')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="class_r_t_protocol.html">RTProtocol</a></td></tr>
<tr class="memitem:abf537db66f86337bdc9dad4e91e86ec8 inherit pro_types_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="abf537db66f86337bdc9dad4e91e86ec8" name="abf537db66f86337bdc9dad4e91e86ec8"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>BindingNotification</b> = 1
, <b>RegisteredAsSAP</b> = 2
, <b>SendTypeCheck</b> = 4
, <b>ReceiveTypeCheck</b> = 8
, <br />
&#160;&#160;<b>Resized</b> = 16
<br />
 }</td></tr>
<tr class="separator:abf537db66f86337bdc9dad4e91e86ec8 inherit pro_types_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac8e5422790b78a36a5e99deff8dbae inherit pro_types_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="a2ac8e5422790b78a36a5e99deff8dbae" name="a2ac8e5422790b78a36a5e99deff8dbae"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>rtiLast_RTProtocol</b> = 0
 }</td></tr>
<tr class="separator:a2ac8e5422790b78a36a5e99deff8dbae inherit pro_types_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_r_t_protocol"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_r_t_protocol')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_r_t_protocol.html">RTProtocol</a></td></tr>
<tr class="memitem:ac7a17e8dc831575b8b324c123af2b0da inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ac7a17e8dc831575b8b324c123af2b0da" name="ac7a17e8dc831575b8b324c123af2b0da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (const <a class="el" href="struct_r_t_port_descriptor.html">RTPortDescriptor</a> *)</td></tr>
<tr class="separator:ac7a17e8dc831575b8b324c123af2b0da inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab821319dd07a3ef521765d9260783898 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ab821319dd07a3ef521765d9260783898" name="ab821319dd07a3ef521765d9260783898"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getFlags</b> (void) const</td></tr>
<tr class="separator:ab821319dd07a3ef521765d9260783898 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13b117f2c7538cb426e361fba7426ef inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ab13b117f2c7538cb426e361fba7426ef" name="ab13b117f2c7538cb426e361fba7426ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setFlag</b> (int)</td></tr>
<tr class="separator:ab13b117f2c7538cb426e361fba7426ef inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc08d99d20ab533b5079e3aa074e892 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="acbc08d99d20ab533b5079e3aa074e892" name="acbc08d99d20ab533b5079e3aa074e892"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetFlag</b> (int)</td></tr>
<tr class="separator:acbc08d99d20ab533b5079e3aa074e892 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8e009f25cb11e3f94b3e8b1a03e885 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="a1b8e009f25cb11e3f94b3e8b1a03e885" name="a1b8e009f25cb11e3f94b3e8b1a03e885"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bindAt</b> (int, <a class="el" href="struct_r_t_binding_end.html">RTBindingEnd</a> &amp;, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:a1b8e009f25cb11e3f94b3e8b1a03e885 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab999150c4dc37ce4cbc4390b847f39fb inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ab999150c4dc37ce4cbc4390b847f39fb" name="ab999150c4dc37ce4cbc4390b847f39fb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>peerAt</b> (int, <a class="el" href="struct_r_t_binding_end.html">RTBindingEnd</a> &amp;)</td></tr>
<tr class="separator:ab999150c4dc37ce4cbc4390b847f39fb inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12e8428f1305054a5ddf074f19b595a inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="ae12e8428f1305054a5ddf074f19b595a" name="ae12e8428f1305054a5ddf074f19b595a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unbindAt</b> (int, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:ae12e8428f1305054a5ddf074f19b595a inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7adb291e96c24590673c557299d052e inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="aa7adb291e96c24590673c557299d052e" name="aa7adb291e96c24590673c557299d052e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>notifyInit</b> (<a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:aa7adb291e96c24590673c557299d052e inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2536ee9af988c7bebd23c626cb3f4898 inherit pro_methods_class_r_t_protocol"><td class="memItemLeft" align="right" valign="top"><a id="a2536ee9af988c7bebd23c626cb3f4898" name="a2536ee9af988c7bebd23c626cb3f4898"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>notifyBoundAt</b> (int, <a class="el" href="class_r_t_controller.html">RTController</a> *)</td></tr>
<tr class="separator:a2536ee9af988c7bebd23c626cb3f4898 inherit pro_methods_class_r_t_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a frame service port. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a676b79ba62d1dd095147d19afbbe83dc" name="a676b79ba62d1dd095147d19afbbe83dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676b79ba62d1dd095147d19afbbe83dc">&#9670;&#160;</a></span>classIsKindOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Frame::Base::classIsKindOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;&#160;</td>
          <td class="paramname"><em>subClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;&#160;</td>
          <td class="paramname"><em>superClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a capsule is the same or inherits from another capsule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subClass</td><td>A capsule to compare the type of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">superClass</td><td>Another capsule to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if subClass == superClass, or if subClass inherits from superClass. Otherwise 0 is returned. </dd></dl>

</div>
</div>
<a id="a0b553a95f5763a925a8db8e9a0f39bcd" name="a0b553a95f5763a925a8db8e9a0f39bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b553a95f5763a925a8db8e9a0f39bcd">&#9670;&#160;</a></span>className()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Frame::Base::className </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of a capsule type. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the capsule as defined in the model. </dd></dl>

</div>
</div>
<a id="a82acc65c4100b16c785f5dfdb6371db1" name="a82acc65c4100b16c785f5dfdb6371db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82acc65c4100b16c785f5dfdb6371db1">&#9670;&#160;</a></span>classOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp; Frame::Base::classOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_r_t_actor_id.html">RTActorId</a> &amp;&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of a certain capsule instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>A capsule instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capsule that is the type of the capsule instance, or EmptyActorClass in case an error occurs. </dd></dl>

</div>
</div>
<a id="a21cc4c11e574d401cb4fbcbb18614c82" name="a21cc4c11e574d401cb4fbcbb18614c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cc4c11e574d401cb4fbcbb18614c82">&#9670;&#160;</a></span>deport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Frame::Base::deport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_r_t_actor_id.html">RTActorId</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a capsule instance from a plug-in capsule part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The capsule instance to remove (deport). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The plug-in capsule part where the capsule instance is currently located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the capsule instance was successfully deported, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a4035fe02a9096ae4157fd92986171737" name="a4035fe02a9096ae4157fd92986171737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4035fe02a9096ae4157fd92986171737">&#9670;&#160;</a></span>destroy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Frame::Base::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a capsule instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The capsule instance to destroy. It must be located in an optional capsule part within the same capsule that owns the frame service port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the capsule instance was successfully destroyed, otherwise 0. </dd></dl>

</div>
</div>
<a id="abbc2649d7e6a4731e285edcf158c09ac" name="abbc2649d7e6a4731e285edcf158c09ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc2649d7e6a4731e285edcf158c09ac">&#9670;&#160;</a></span>destroy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Frame::Base::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy all capsule instances contained in a certain capsule part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The capsule part. It must be optional and located within the same capsule that owns the frame service port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of destroyed capsule instances. 0 is returned in case of errors. </dd></dl>

</div>
</div>
<a id="a3ba6a0fa29d13eed653f3fe619157287" name="a3ba6a0fa29d13eed653f3fe619157287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba6a0fa29d13eed653f3fe619157287">&#9670;&#160;</a></span>import() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Frame::Base::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_r_t_actor_id.html">RTActorId</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a capsule instance into a plug-in capsule part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Capsule instance to import. It must be located in an optional capsule part within the same capsule that owns the frame service port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp_dest</td><td>The destination capsule part into which the capsule instance will be imported. It must be a plug-in capsule part typed by a capsule that is compatible with the type of the imported capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index within a replicated capsule part where to insert the imported capsule instance. Use -1 to insert the instance at the first free slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the capsule instance was successfully imported, 0 otherwise. </dd></dl>

</div>
</div>
<a id="af168da4bbb8e78c2ddd0d5557ac8eb26" name="af168da4bbb8e78c2ddd0d5557ac8eb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af168da4bbb8e78c2ddd0d5557ac8eb26">&#9670;&#160;</a></span>import() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Frame::Base::import </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a capsule instance into a plug-in capsule part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp_src</td><td>An optional capsule part that contains exactly one capsule instance that should be imported into another plug-in capsule part. The source capsule part must be located within the same capsule that owns the frame service port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cp_dest</td><td>The destination capsule part into which the capsule instance will be imported. It must be a plug-in capsule part typed by a capsule that is compatible with the type of the imported capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index within a replicated capsule part where to insert the imported capsule instance. Use -1 to insert the instance at the first free slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the capsule instance was successfully imported, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a07be3539821c3a830ed3239adfccfed6" name="a07be3539821c3a830ed3239adfccfed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07be3539821c3a830ed3239adfccfed6">&#9670;&#160;</a></span>incarnate() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::incarnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incarnates a capsule by creating an instance of the capsule in an optional capsule part. </p>
<p>The capsule to incarnate is determined from the type of the capsule part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The capsule part where to insert the created capsule instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_r_t_actor_id.html" title="An object that identifies a capsule instance at run-time.">RTActorId</a> representing the created capsule instance. </dd></dl>

</div>
</div>
<a id="a314b65d73a6040eb1153909e2238e185" name="a314b65d73a6040eb1153909e2238e185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314b65d73a6040eb1153909e2238e185">&#9670;&#160;</a></span>incarnate() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::incarnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incarnates a capsule by creating an instance of the capsule in an optional capsule part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The capsule part where to insert the created capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>The capsule to incarnate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_r_t_actor_id.html" title="An object that identifies a capsule instance at run-time.">RTActorId</a> representing the created capsule instance. </dd></dl>

</div>
</div>
<a id="a6ece127551d69cffb999f4008d541984" name="a6ece127551d69cffb999f4008d541984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ece127551d69cffb999f4008d541984">&#9670;&#160;</a></span>incarnate() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::incarnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_controller.html">RTController</a> *&#160;</td>
          <td class="paramname"><em>controller</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incarnates a capsule by creating an instance of the capsule in an optional capsule part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The capsule part where to insert the created capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>The capsule to incarnate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object to pass to the created capsule instance. The data can be accessed from the initial transition of its state machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controller</td><td>The controller which should run the created capsule instance. If it is NULL, the same controller that runs the container capsule instance will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index within a replicated capsule part where to insert the created capsule instance. Use -1 to insert the instance at the first free slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_r_t_actor_id.html" title="An object that identifies a capsule instance at run-time.">RTActorId</a> representing the created capsule instance. </dd></dl>

</div>
</div>
<a id="a55cdd3c957cff7c5068636024a375aec" name="a55cdd3c957cff7c5068636024a375aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cdd3c957cff7c5068636024a375aec">&#9670;&#160;</a></span>incarnate() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::incarnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_controller.html">RTController</a> *&#160;</td>
          <td class="paramname"><em>controller</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incarnates a capsule by creating an instance of the capsule in an optional capsule part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The capsule part where to insert the created capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>The capsule to incarnate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>An <a class="el" href="struct_r_t_typed_value.html" title="Encapsulates a data object and its type descriptor.">RTTypedValue</a> object which encapsules the data to pass to the created capsule instance. The data can be accessed from the initial transition of its state machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controller</td><td>The controller which should run the created capsule instance. If it is NULL, the same controller that runs the container capsule instance will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index within a replicated capsule part where to insert the created capsule instance. Use -1 to insert the instance at the first free slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_r_t_actor_id.html" title="An object that identifies a capsule instance at run-time.">RTActorId</a> representing the created capsule instance. </dd></dl>

</div>
</div>
<a id="a0c8aa336e2bde505835c046811eccdbb" name="a0c8aa336e2bde505835c046811eccdbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8aa336e2bde505835c046811eccdbb">&#9670;&#160;</a></span>incarnate() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::incarnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp;&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_controller.html">RTController</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incarnates a capsule by creating an instance of the capsule in an optional capsule part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The capsule part where to insert the created capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>The capsule to incarnate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Initialization data to pass to the created capsule instance. It can be accessed from the initial transition of its state machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type descriptor for the data object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controller</td><td>The controller which should run the created capsule instance. If it is NULL, the same controller that runs the container capsule instance will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index within a replicated capsule part where to insert the created capsule instance. Use -1 to insert the instance at the first free slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_r_t_actor_id.html" title="An object that identifies a capsule instance at run-time.">RTActorId</a> representing the created capsule instance. </dd></dl>

</div>
</div>
<a id="ac0a3a112ba0c13dffdaf249b5f9b910d" name="ac0a3a112ba0c13dffdaf249b5f9b910d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a3a112ba0c13dffdaf249b5f9b910d">&#9670;&#160;</a></span>incarnate() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::incarnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_t_data_object.html">RTDataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_controller.html">RTController</a> *&#160;</td>
          <td class="paramname"><em>controller</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incarnates a capsule by creating an instance of the capsule in an optional capsule part. </p>
<p>The capsule to incarnate is determined from the type of the capsule part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The capsule part where to insert the created capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data object to pass to the created capsule instance. The data can be accessed from the initial transition of its state machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controller</td><td>The controller which should run the created capsule instance. If it is NULL, the same controller that runs the container capsule instance will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index within a replicated capsule part where to insert the created capsule instance. Use -1 to insert the instance at the first free slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_r_t_actor_id.html" title="An object that identifies a capsule instance at run-time.">RTActorId</a> representing the created capsule instance. </dd></dl>

</div>
</div>
<a id="a5061b37c597cebd1786548e4e4663afe" name="a5061b37c597cebd1786548e4e4663afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5061b37c597cebd1786548e4e4663afe">&#9670;&#160;</a></span>incarnate() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::incarnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_typed_value.html">RTTypedValue</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_controller.html">RTController</a> *&#160;</td>
          <td class="paramname"><em>controller</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incarnates a capsule by creating an instance of the capsule in an optional capsule part. </p>
<p>The capsule to incarnate is determined from the type of the capsule part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The capsule part where to insert the created capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>An <a class="el" href="struct_r_t_typed_value.html" title="Encapsulates a data object and its type descriptor.">RTTypedValue</a> object which encapsules the data to pass to the created capsule instance. The data can be accessed from the initial transition of its state machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controller</td><td>The controller which should run the created capsule instance. If it is NULL, the same controller that runs the container capsule instance will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index within a replicated capsule part where to insert the created capsule instance. Use -1 to insert the instance at the first free slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_r_t_actor_id.html" title="An object that identifies a capsule instance at run-time.">RTActorId</a> representing the created capsule instance. </dd></dl>

</div>
</div>
<a id="abafaa6fc5066d572068b068497646b7a" name="abafaa6fc5066d572068b068497646b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafaa6fc5066d572068b068497646b7a">&#9670;&#160;</a></span>incarnate() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::incarnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_controller.html">RTController</a> *&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incarnates a capsule by creating an instance of the capsule in an optional capsule part. </p>
<p>The capsule to incarnate is determined from the type of the capsule part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The capsule part where to insert the created capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Initialization data to pass to the created capsule instance. It can be accessed from the initial transition of its state machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type descriptor for the data object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controller</td><td>The controller which should run the created capsule instance. If it is NULL, the same controller that runs the container capsule instance will be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index within a replicated capsule part where to insert the created capsule instance. Use -1 to insert the instance at the first free slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_r_t_actor_id.html" title="An object that identifies a capsule instance at run-time.">RTActorId</a> representing the created capsule instance. </dd></dl>

</div>
</div>
<a id="a39322bc4f2d83da6cd22bdd6c40af51a" name="a39322bc4f2d83da6cd22bdd6c40af51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39322bc4f2d83da6cd22bdd6c40af51a">&#9670;&#160;</a></span>incarnateCustom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::incarnateCustom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_r_t_object__class.html">RTObject_class</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_factory.html">RTActorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incarnates a capsule by creating an instance of the capsule in an optional capsule part using a custom capsule factory for creating the capsule instance. </p>
<p>Use this instead of the standard incarnate function if you need to create the capsule instance in some special way, for example using another capsule constructor than the one that is used by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The capsule part where to insert the created capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Initialization data to pass to the created capsule instance. It can be accessed from the initial transition of its state machine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type descriptor for the data object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factory</td><td>The capsule factory which will be used for creating the capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index within a replicated capsule part where to insert the created capsule instance. Use -1 to insert the instance at the first free slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_r_t_actor_id.html" title="An object that identifies a capsule instance at run-time.">RTActorId</a> representing the created capsule instance. </dd></dl>

</div>
</div>
<a id="a0aa0d901c0c7ea0006c841d2161a460f" name="a0aa0d901c0c7ea0006c841d2161a460f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa0d901c0c7ea0006c841d2161a460f">&#9670;&#160;</a></span>incarnateCustom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::incarnateCustom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_t_actor_factory.html">RTActorFactory</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incarnates a capsule by creating an instance of the capsule in an optional capsule part using a custom capsule factory for creating the capsule instance. </p>
<p>Use this instead of the standard incarnate function if you need to create the capsule instance in some special way, for example using another capsule constructor than the one that is used by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>The capsule part where to insert the created capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factory</td><td>The capsule factory which will be used for creating the capsule instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index within a replicated capsule part where to insert the created capsule instance. Use -1 to insert the instance at the first free slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_r_t_actor_id.html" title="An object that identifies a capsule instance at run-time.">RTActorId</a> representing the created capsule instance. </dd></dl>

</div>
</div>
<a id="a3bf5762e13d02bac97389a6d832a4ab3" name="a3bf5762e13d02bac97389a6d832a4ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf5762e13d02bac97389a6d832a4ab3">&#9670;&#160;</a></span>incarnationAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::incarnationAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a capsule instance contained in a certain capsule part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>A capsule part. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The zero-based index of the capsule instance within the capsule part. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af81906fa782eb2b6459a0f068f044154" name="af81906fa782eb2b6459a0f068f044154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81906fa782eb2b6459a0f068f044154">&#9670;&#160;</a></span>incarnationsOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> ** Frame::Base::incarnationsOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_r_t_actor_ref.html">RTActorRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all capsule instances contained in a certain capsule part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cp</td><td>A capsule part. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of pointers to the capsule instances that are contained in the capsule part. The first and last element of the array is NULL, which means that you should use 1-based indexing for accessing a specific capsule instance. Note that it is the caller's responsibility to delete the returned array. If you only want to access one capsule instance it is therefore better to use <a class="el" href="class_frame_1_1_base.html#a3bf5762e13d02bac97389a6d832a4ab3" title="Return a capsule instance contained in a certain capsule part.">incarnationAt()</a>. </dd></dl>

</div>
</div>
<a id="a1d08050ba8e0711e3136eb6064f11510" name="a1d08050ba8e0711e3136eb6064f11510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d08050ba8e0711e3136eb6064f11510">&#9670;&#160;</a></span>me()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_t_actor_id.html">RTActorId</a> Frame::Base::me </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the capsule instance that owns the frame service port. </p>
<dl class="section return"><dt>Returns</dt><dd>The context capsule instance. </dd></dl>

</div>
</div>
<a id="aa26682baa7d0b8ff291200bf7c3e1b10" name="aa26682baa7d0b8ff291200bf7c3e1b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26682baa7d0b8ff291200bf7c3e1b10">&#9670;&#160;</a></span>myClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_r_t_actor_class.html">RTActorClass</a> &amp; Frame::Base::myClass </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of the capsule instance that owns the frame service port. </p>
<dl class="section return"><dt>Returns</dt><dd>The capsule that is the type of the context capsule instance. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_r_t_frame_8h_source.html">RTFrame.h</a></li>
<li>RTFrame.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
